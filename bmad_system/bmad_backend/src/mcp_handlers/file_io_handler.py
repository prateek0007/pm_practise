"""
File I/O Handler Module for BMAD System

This module manages file system operations, including creating project directories,
reading and writing code to files, and editing existing code files (specifically 
bug sections as per agent directions).
"""

import os
import shutil
import json
import re
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from pathlib import Path
from src.utils.logger import get_logger

logger = get_logger(__name__)

@dataclass
class FileOperation:
    """Represents a file operation result"""
    success: bool
    message: str
    file_path: str = ""
    content: str = ""
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

class FileIOHandler:
    """Handles file system operations for the BMAD system"""
    
    def __init__(self):
        self.base_output_dir = "/tmp/bmad_output"
        self.allowed_extensions = {
            '.py', '.js', '.ts', '.html', '.css', '.json', '.yaml', '.yml',
            '.md', '.txt', '.sql', '.sh', '.bat', '.dockerfile', '.env',
            '.xml', '.csv', '.ini', '.cfg', '.conf'
        }
        self.backup_dir = "/tmp/bmad_backups"
        os.makedirs(self.base_output_dir, exist_ok=True)
        os.makedirs(self.backup_dir, exist_ok=True)
    
    def create_project_directory(self, project_name: str) -> FileOperation:
        """
        Create a new project directory structure
        
        Args:
            project_name: Name of the project
            
        Returns:
            FileOperation with result
        """
        try:
            # Prefer TaskManager's recorded project_path if any task exists that matches this folder
            # This prevents duplicate timestamped folders when subworkflows run
            try:
                from src.core.task_manager import TaskManager
                tm = TaskManager()
                # Scan existing tasks to find project_path ending with project_name
                project_path = None
                try:
                    tasks = tm.get_all_tasks()
                    for t in tasks or []:
                        p = (t.get('project_path') if isinstance(t, dict) else getattr(t, 'project_path', None))
                        if p and p.endswith(f"/{project_name}"):
                            project_path = p
                            break
                except Exception:
                    project_path = None
                if not project_path:
                    project_path = os.path.join(self.base_output_dir, project_name)
            except Exception:
                project_path = os.path.join(self.base_output_dir, project_name)
            
            if os.path.exists(project_path):
                return FileOperation(
                    success=False,
                    message=f"Project directory {project_name} already exists",
                    file_path=project_path
                )
            
            # Create main project directory
            os.makedirs(project_path, exist_ok=True)
            
            # Create .io8project directory
            io8_project_path = os.path.join(project_path, ".io8project")
            os.makedirs(io8_project_path, exist_ok=True)
            
            # Create standard subdirectories
            subdirs = ['src', 'tests', 'docs', 'config']
            for subdir in subdirs:
                os.makedirs(os.path.join(project_path, subdir), exist_ok=True)
            
            # Create initial files
            self._create_initial_files(project_path, io8_project_path)
            
            logger.info(f"Created project directory: {project_path}")
            
            return FileOperation(
                success=True,
                message=f"Successfully created project directory: {project_name}",
                file_path=project_path,
                metadata={
                    'io8_project_path': io8_project_path,
                    'subdirectories': subdirs
                }
            )
            
        except Exception as e:
            logger.error(f"Error creating project directory {project_name}: {e}")
            return FileOperation(
                success=False,
                message=f"Error creating project directory: {str(e)}"
            )
    
    def _create_initial_files(self, project_path: str, io8_project_path: str):
        """Create initial project files"""
        # Create README.md
        readme_content = f"""# {os.path.basename(project_path)}

This project was generated by the BMAD (Break down, Make a plan, Act, Debug) system.

## Project Structure

- `src/` - Source code
- `tests/` - Test files
- `docs/` - Documentation
- `config/` - Configuration files
- `.io8project/` - BMAD system files

## Getting Started

[Instructions will be added by the development agents]
"""
        self.write_file(os.path.join(project_path, "README.md"), readme_content)
        
        # Create .gitignore
        gitignore_content = """# BMAD system files
.io8project/
*.log

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv/

# Node.js
node_modules/
npm-debug.log*

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
"""
        self.write_file(os.path.join(project_path, ".gitignore"), gitignore_content)
        
        # Create initial state file
        initial_state = {
            "project_name": os.path.basename(project_path),
            "created_at": self._get_timestamp(),
            "status": "initialized",
            "agents_completed": [],
            "current_phase": "setup"
        }
        
        state_path = os.path.join(io8_project_path, ".state.json")
        with open(state_path, 'w') as f:
            json.dump(initial_state, f, indent=2)
    
    def write_file(self, file_path: str, content: str, backup: bool = True) -> FileOperation:
        """
        Write content to a file
        
        Args:
            file_path: Path to the file
            content: Content to write
            backup: Whether to create a backup if file exists
            
        Returns:
            FileOperation with result
        """
        try:
            # Validate file extension
            file_ext = os.path.splitext(file_path)[1].lower()
            if file_ext and file_ext not in self.allowed_extensions:
                return FileOperation(
                    success=False,
                    message=f"File extension {file_ext} not allowed",
                    file_path=file_path
                )
            
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            
            # Create backup if file exists and backup is requested
            if backup and os.path.exists(file_path):
                self._create_backup(file_path)
            
            # Write the file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            logger.info(f"Successfully wrote file: {file_path}")
            
            return FileOperation(
                success=True,
                message=f"Successfully wrote file: {os.path.basename(file_path)}",
                file_path=file_path,
                content=content,
                metadata={'size': len(content)}
            )
            
        except Exception as e:
            logger.error(f"Error writing file {file_path}: {e}")
            return FileOperation(
                success=False,
                message=f"Error writing file: {str(e)}",
                file_path=file_path
            )
    
    def read_file(self, file_path: str) -> FileOperation:
        """
        Read content from a file
        
        Args:
            file_path: Path to the file
            
        Returns:
            FileOperation with result and content
        """
        try:
            if not os.path.exists(file_path):
                return FileOperation(
                    success=False,
                    message=f"File not found: {file_path}",
                    file_path=file_path
                )
            
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            return FileOperation(
                success=True,
                message=f"Successfully read file: {os.path.basename(file_path)}",
                file_path=file_path,
                content=content,
                metadata={
                    'size': len(content),
                    'lines': len(content.splitlines())
                }
            )
            
        except Exception as e:
            logger.error(f"Error reading file {file_path}: {e}")
            return FileOperation(
                success=False,
                message=f"Error reading file: {str(e)}",
                file_path=file_path
            )
    
    def edit_file_section(self, file_path: str, section_identifier: str, 
                         new_content: str, section_type: str = "function") -> FileOperation:
        """
        Edit a specific section of a file (e.g., a function, class, or bug fix)
        
        Args:
            file_path: Path to the file
            section_identifier: Identifier for the section (function name, class name, etc.)
            new_content: New content for the section
            section_type: Type of section ('function', 'class', 'method', 'bug_fix')
            
        Returns:
            FileOperation with result
        """
        try:
            # Read the existing file
            read_result = self.read_file(file_path)
            if not read_result.success:
                return read_result
            
            original_content = read_result.content
            
            # Create backup
            self._create_backup(file_path)
            
            # Edit the section based on type
            if section_type == "function":
                modified_content = self._edit_function(original_content, section_identifier, new_content)
            elif section_type == "class":
                modified_content = self._edit_class(original_content, section_identifier, new_content)
            elif section_type == "method":
                modified_content = self._edit_method(original_content, section_identifier, new_content)
            elif section_type == "bug_fix":
                modified_content = self._apply_bug_fix(original_content, section_identifier, new_content)
            else:
                return FileOperation(
                    success=False,
                    message=f"Unknown section type: {section_type}",
                    file_path=file_path
                )
            
            if modified_content == original_content:
                return FileOperation(
                    success=False,
                    message=f"Section '{section_identifier}' not found in file",
                    file_path=file_path
                )
            
            # Write the modified content
            write_result = self.write_file(file_path, modified_content, backup=False)
            
            if write_result.success:
                write_result.message = f"Successfully edited {section_type} '{section_identifier}' in {os.path.basename(file_path)}"
                write_result.metadata = {
                    'section_type': section_type,
                    'section_identifier': section_identifier,
                    'original_size': len(original_content),
                    'new_size': len(modified_content)
                }
            
            return write_result
            
        except Exception as e:
            logger.error(f"Error editing file section {file_path}: {e}")
            return FileOperation(
                success=False,
                message=f"Error editing file section: {str(e)}",
                file_path=file_path
            )
    
    def _edit_function(self, content: str, function_name: str, new_function_content: str) -> str:
        """Edit a specific function in the content"""
        # This is a simplified implementation
        # In a real system, you'd use proper AST parsing for each language
        
        # Python function pattern
        pattern = rf"(def\s+{re.escape(function_name)}\s*\([^)]*\):[^\\n]*\\n)(.*?)(?=\\ndef\s|\\nclass\s|\\n\\n\\S|$)"
        
        def replace_function(match):
            return match.group(1) + new_function_content
        
        modified = re.sub(pattern, replace_function, content, flags=re.DOTALL)
        return modified
    
    def _edit_class(self, content: str, class_name: str, new_class_content: str) -> str:
        """Edit a specific class in the content"""
        pattern = rf"(class\s+{re.escape(class_name)}[^:]*:[^\\n]*\\n)(.*?)(?=\\nclass\s|\\ndef\s+\\w|\\n\\n\\S|$)"
        
        def replace_class(match):
            return match.group(1) + new_class_content
        
        modified = re.sub(pattern, replace_class, content, flags=re.DOTALL)
        return modified
    
    def _edit_method(self, content: str, method_name: str, new_method_content: str) -> str:
        """Edit a specific method in the content"""
        # Similar to function but within a class context
        pattern = rf"(\\s+def\s+{re.escape(method_name)}\s*\([^)]*\):[^\\n]*\\n)(.*?)(?=\\s+def\s|\\nclass\s|\\n\\n\\S|$)"
        
        def replace_method(match):
            return match.group(1) + new_method_content
        
        modified = re.sub(pattern, replace_method, content, flags=re.DOTALL)
        return modified
    
    def _apply_bug_fix(self, content: str, bug_identifier: str, fix_content: str) -> str:
        """Apply a bug fix to specific lines or sections"""
        # This could be line numbers, error patterns, etc.
        # For now, simple string replacement
        if bug_identifier in content:
            return content.replace(bug_identifier, fix_content)
        return content
    
    def _create_backup(self, file_path: str):
        """Create a backup of the file"""
        try:
            if os.path.exists(file_path):
                timestamp = self._get_timestamp().replace(":", "-").replace(" ", "_")
                backup_name = f"{os.path.basename(file_path)}.backup_{timestamp}"
                backup_path = os.path.join(self.backup_dir, backup_name)
                shutil.copy2(file_path, backup_path)
                logger.info(f"Created backup: {backup_path}")
        except Exception as e:
            logger.warning(f"Failed to create backup for {file_path}: {e}")
    
    def list_files(self, directory_path: str, pattern: str = "*") -> FileOperation:
        """
        List files in a directory
        
        Args:
            directory_path: Path to the directory
            pattern: File pattern to match
            
        Returns:
            FileOperation with file list
        """
        try:
            if not os.path.exists(directory_path):
                return FileOperation(
                    success=False,
                    message=f"Directory not found: {directory_path}"
                )
            
            path = Path(directory_path)
            files = list(path.glob(pattern))
            
            file_list = []
            for file_path in files:
                if file_path.is_file():
                    file_info = {
                        'name': file_path.name,
                        'path': str(file_path),
                        'size': file_path.stat().st_size,
                        'modified': file_path.stat().st_mtime
                    }
                    file_list.append(file_info)
            
            return FileOperation(
                success=True,
                message=f"Found {len(file_list)} files",
                metadata={'files': file_list, 'directory': directory_path}
            )
            
        except Exception as e:
            logger.error(f"Error listing files in {directory_path}: {e}")
            return FileOperation(
                success=False,
                message=f"Error listing files: {str(e)}"
            )
    
    def delete_file(self, file_path: str, backup: bool = True) -> FileOperation:
        """
        Delete a file
        
        Args:
            file_path: Path to the file
            backup: Whether to create a backup before deletion
            
        Returns:
            FileOperation with result
        """
        try:
            if not os.path.exists(file_path):
                return FileOperation(
                    success=False,
                    message=f"File not found: {file_path}",
                    file_path=file_path
                )
            
            # Create backup if requested
            if backup:
                self._create_backup(file_path)
            
            os.remove(file_path)
            
            logger.info(f"Deleted file: {file_path}")
            
            return FileOperation(
                success=True,
                message=f"Successfully deleted file: {os.path.basename(file_path)}",
                file_path=file_path
            )
            
        except Exception as e:
            logger.error(f"Error deleting file {file_path}: {e}")
            return FileOperation(
                success=False,
                message=f"Error deleting file: {str(e)}",
                file_path=file_path
            )
    
    def copy_file(self, source_path: str, destination_path: str) -> FileOperation:
        """
        Copy a file from source to destination
        
        Args:
            source_path: Source file path
            destination_path: Destination file path
            
        Returns:
            FileOperation with result
        """
        try:
            if not os.path.exists(source_path):
                return FileOperation(
                    success=False,
                    message=f"Source file not found: {source_path}"
                )
            
            # Create destination directory if it doesn't exist
            os.makedirs(os.path.dirname(destination_path), exist_ok=True)
            
            shutil.copy2(source_path, destination_path)
            
            logger.info(f"Copied file from {source_path} to {destination_path}")
            
            return FileOperation(
                success=True,
                message=f"Successfully copied file to {os.path.basename(destination_path)}",
                file_path=destination_path
            )
            
        except Exception as e:
            logger.error(f"Error copying file from {source_path} to {destination_path}: {e}")
            return FileOperation(
                success=False,
                message=f"Error copying file: {str(e)}"
            )
    
    def _get_timestamp(self) -> str:
        """Get current timestamp string"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def get_project_structure(self, project_path: str) -> Dict[str, Any]:
        """Get the structure of a project directory"""
        try:
            structure = {}
            
            for root, dirs, files in os.walk(project_path):
                rel_root = os.path.relpath(root, project_path)
                if rel_root == ".":
                    rel_root = ""
                
                structure[rel_root] = {
                    'directories': dirs,
                    'files': files
                }
            
            return structure
            
        except Exception as e:
            logger.error(f"Error getting project structure for {project_path}: {e}")
            return {}

