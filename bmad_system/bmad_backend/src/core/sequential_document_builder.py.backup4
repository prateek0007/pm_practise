import os
import logging
import json
import os
from typing import Dict, List, Any
from src.utils.logger import get_logger
import re
import time
import subprocess

logger = get_logger(__name__)

class SequentialDocumentBuilder:
    """Builds documents sequentially based on previous agent outputs"""
    
    def __init__(self):
        self.document_templates = {
            'directory_structure': {
                'input_files': [],
                'output_files': [],
                'executor': self._execute_directory_structure_phase
            },
            'io8directory_structure': {
                'input_files': [],
                'output_files': [],
                'executor': self._execute_directory_structure_phase
            },
            'io8codermaster': {
                'input_files': [],
                'output_files': ['.sureai/.io8codermaster_breakdown.md', '.sureai/.io8codermaster_plan.md'],
                'executor': self._execute_io8codermaster_phase
            },
            'analyst': {
                'input_files': ['.sureai/.io8codermaster_breakdown.md', '.sureai/.io8codermaster_plan.md'],
                'output_files': ['.sureai/analysis_document.md', '.sureai/requirements_document.md'],
                'executor': self._execute_analyst_phase
            },
            'io8analyst': {
                'input_files': ['.sureai/.io8codermaster_breakdown.md', '.sureai/.io8codermaster_plan.md'],
                'output_files': ['.sureai/analysis_document.md', '.sureai/requirements_document.md'],
                'executor': self._execute_io8analyst_phase
            },
            'architect': {
                'input_files': ['.sureai/analysis_document.md', '.sureai/requirements_document.md'],
                'output_files': ['.sureai/architecture_document.md', '.sureai/tech_stack_document.md'],
                'executor': self._execute_architect_phase
            },
            'io8architect': {
                'input_files': ['.sureai/analysis_document.md', '.sureai/requirements_document.md'],
                'output_files': ['.sureai/architecture_document.md', '.sureai/tech_stack_document.md'],
                'executor': self._execute_io8architect_phase
            },
            'coding_standards': {
                'input_files': ['.sureai/tech_stack_document.md'],
                'output_files': ['.sureai/coding-standard.md'],
                'executor': self._execute_coding_standards_phase
            },
            'ui_ux': {
                'input_files': ['.sureai/tech_stack_document.md'],
                'output_files': ['.sureai/ui-ux.md'],
                'executor': self._execute_ui_ux_phase
            },
            'pm': {
                'input_files': ['.sureai/analysis_document.md', '.sureai/architecture_document.md'],
                'output_files': ['.sureai/prd_document.md', '.sureai/project_plan.md'],
                'executor': self._execute_pm_phase
            },
            'io8pm': {
                'input_files': ['.sureai/analysis_document.md', '.sureai/architecture_document.md', '.sureai/tech_stack_document.md'],
                'output_files': ['.sureai/prd_document.md', '.sureai/project_plan.md'],
                'executor': self._execute_io8pm_phase
            },
            'sm': {
                'input_files': ['.sureai/prd_document.md'],
                'output_files': ['.sureai/tasks_list.md', '.sureai/sprint_plan.md'],
                'executor': self._execute_sm_phase
            },
            'io8sm': {
                'input_files': ['.sureai/prd_document.md'],
                'output_files': ['.sureai/tasks_list.md', '.sureai/sprint_plan.md'],
                'executor': self._execute_sm_phase
            },
            'io8_mcp_project': {
                'input_files': ['.sureai/project_plan.md', '.sureai/architecture_document.md', '.sureai/tech_stack_document.md'],
                'output_files': ['.sureai/project_builder_plan.md'],
                'executor': self._execute_io8_mcp_project_phase
            },
            'requirement_builder': {
                'input_files': [],
                'output_files': ['.sureai/requirements_extracted.json'],
                'executor': self._execute_requirement_builder_phase
            },
            'developer': {
                'input_files': ['.sureai/tasks_list.md', '.sureai/architecture_document.md', '.sureai/tech_stack_document.md', '.sureai/common-bug.md'],
                'output_files': ['.sureai/tasks_list.md', 'backend/', 'frontend/'],
                'executor': self._execute_developer_phase
            },
            'io8developer': {
                'input_files': ['.sureai/tasks_list.md', '.sureai/architecture_document.md', '.sureai/tech_stack_document.md', '.sureai/common-bug.md'],
                'output_files': ['.sureai/tasks_list.md', 'backend/', 'frontend/'],
                'executor': self._execute_developer_phase
            },
            'devops': {
                'input_files': ['backend/', 'frontend/', '.sureai/architecture_document.md'],
                'output_files': ['deployment_config.yml', 'Dockerfile.backend', 'Dockerfile.frontend', 'docker-compose.yml', 'nginx.conf'],
                'executor': self._execute_devops_phase
            },
            'io8devops': {
                'input_files': ['backend/', 'frontend/', '.sureai/architecture_document.md'],
                'output_files': ['deployment_config.yml', 'Dockerfile.backend', 'Dockerfile.frontend', 'docker-compose.yml', 'nginx.conf'],
                'executor': self._execute_devops_phase
            },
            'tester': {
                'input_files': ['.sureai/architecture_document.md', 'backend/', 'frontend/'],
                'output_files': ['.sureai/test-list.md'],
                'executor': self._execute_tester_phase
            },
            'documentation_agent': {
                'input_files': ['.sureai/prd_document.md', '.sureai/architecture_document.md'],
                'output_files': ['technical_manual.md', 'user_manual.md'],
                'executor': self._execute_documentation_phase
            },
            'web_search': {
                'input_files': [],
                'output_files': ['.sureai/web-results.md'],
                'executor': self._execute_web_search_phase
            },
            'deep_research': {
                'input_files': ['.sureai/web-results.md', '.sureai/requirements_extracted.json', '.sureai/analysis_document.md'],
                'output_files': ['.sureai/research-results.md'],
                'executor': self._execute_deep_research_phase
            }
        }
    
    def _log_prompt_to_gemini(self, agent_name: str, prompt: str, agent_prompt: str, previous_docs: Dict[str, str]):
        # Logs complete prompt details for debugging and monitoring
        """Log the complete prompt being sent to the selected CLI"""
        logger.info(f"=== SENDING PROMPT TO CLI FOR {agent_name.upper()} ===")
        logger.info(f"PROMPT LENGTH: {len(prompt)} characters")
        logger.info(f"AGENT PROMPT LENGTH: {len(agent_prompt)} characters")
        logger.info(f"PREVIOUS DOCUMENTS COUNT: {len(previous_docs)}")
        logger.info("PREVIOUS DOCUMENTS:")
        for doc_name, doc_content in previous_docs.items():
            logger.info(f"  - {doc_name}: {len(doc_content)} characters")
        # Extra observability for memory injection
        if "=== MEMORY JSON (Latest) ===" in prompt:
            start = prompt.find("=== MEMORY JSON (Latest) ===")
            logger.info("MEMORY JSON DETECTED IN PROMPT")
            logger.debug(prompt[start: start + 800])
        else:
            logger.warning("MEMORY JSON NOT FOUND IN PROMPT")
        # Check for agent instructions in the prompt
        if "=== AGENT INSTRUCTIONS ===" in prompt:
            start = prompt.find("=== AGENT INSTRUCTIONS ===")
            end = prompt.find("\n\n", start + 25)  # 25 is length of "=== AGENT INSTRUCTIONS ==="
            if end == -1:  # If no double newline found, take the rest of the prompt
                end = len(prompt)
            instructions_preview = prompt[start:end]
            logger.info("AGENT INSTRUCTIONS DETECTED IN PROMPT")
            logger.info(f"AGENT INSTRUCTIONS PREVIEW: {instructions_preview[:200]}...")
        else:
            logger.warning("AGENT INSTRUCTIONS NOT FOUND IN PROMPT")
        logger.info("FULL PROMPT:")
        logger.info("=" * 80)
        logger.info(prompt)
        logger.info("=" * 80)
    
    def _get_gemini_client(self):
        """Get a properly configured Gemini CLI client"""
        try:
            # Always use the shared client so model switches apply here too
            from src.routes.bmad_api import gemini_cli_client
            return gemini_cli_client
        except Exception as e:
            raise ValueError(f"No shared Gemini client available: {e}")
    
    def _get_cli_client(self, task_id: str, agent_name: str):
        """Return the selected CLI client for this agent: surecli | llxprt | gemini (default)."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            state = tm.get_task_state(task_id)
            chosen = 'gemini'
            if state and isinstance(state.context, dict):
                seq = state.context.get('agent_sequence') or []
                clis = state.context.get('agent_clis') or []
                if isinstance(seq, list) and isinstance(clis, list):
                    try:
                        idx = seq.index(agent_name)
                        if idx < len(clis) and clis[idx] in ['gemini', 'llxprt', 'surecli']:
                            chosen = clis[idx]
                    except ValueError:
                        pass
            # Force developer to gemini for code generation fidelity
            if agent_name == 'developer' and chosen != 'gemini':
                logger.warning(f"Developer step requires Gemini CLI; overriding selected '{chosen}' with 'gemini'")
                chosen = 'gemini'
            if chosen == 'llxprt':
                try:
                    from src.routes.bmad_api import llxprt_cli_client
                    logger.info(f"Using LLXPRT CLI for agent {agent_name}")
                    return llxprt_cli_client
                except Exception as e:
                    logger.warning(f"LLXPRT client unavailable, falling back to Gemini for {agent_name}: {e}")
            elif chosen == 'surecli':
                try:
                    from src.routes.bmad_api import sure_cli_client
                    logger.info(f"Using SureCli for agent {agent_name}")
                    logger.info("Python parser will generate text and write resulting files under .sureai/")
                    return sure_cli_client
                except Exception as e:
                    logger.warning(f"SureCli client unavailable, falling back to Gemini for {agent_name}: {e}")
            # default
            client = self._get_gemini_client()
            logger.info(f"Using Gemini CLI for agent {agent_name}")
            return client
        except Exception as e:
            logger.warning(f"CLI selection failed for {agent_name}, defaulting to Gemini: {e}")
            return self._get_gemini_client()
    
    def _get_agent_prompt(self, agent_name: str) -> str:
        """Get agent prompt from AgentManager"""
        try:
            from src.routes.bmad_api import agent_manager
            agent_prompt = agent_manager.get_agent_prompt(agent_name)
            if agent_prompt:
                logger.info(f"Loaded agent prompt for {agent_name} from AgentManager")
                return agent_prompt
            else:
                logger.warning(f"No agent prompt found for {agent_name} in AgentManager")
                return ""
        except Exception as e:
            logger.error(f"Error getting agent prompt for {agent_name}: {e}")
            return ""

    def _get_agent_instructions(self, agent_name: str) -> str:
        """Get agent instructions from AgentManager"""
        try:
            from src.routes.bmad_api import agent_manager
            agent_instructions = agent_manager.get_agent_instructions(agent_name)
            if agent_instructions:
                logger.info(f"Loaded agent instructions for {agent_name} from AgentManager")
                return agent_instructions
            else:
                logger.warning(f"No agent instructions found for {agent_name} in AgentManager")
                return ""
        except Exception as e:
            logger.error(f"Error getting agent instructions for {agent_name}: {e}")
            return ""

    def _get_agent_temperature(self, task_id: str, agent_name: str) -> float | None:
        """Fetch the per-agent temperature from TaskState context if present."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            state = tm.get_task_state(task_id)
            if not state or not isinstance(state.context, dict):
                return None
            seq = state.context.get('agent_sequence') or []
            temps = state.context.get('agent_temperatures') or []
            if not isinstance(seq, list) or not isinstance(temps, list):
                return None
            # Find first occurrence index for agent_name
            try:
                idx = seq.index(agent_name)
            except ValueError:
                return None
            if idx < len(temps):
                return temps[idx]
            return None
        except Exception:
            return None

    def _temperature_guidance(self, temperature: float) -> str:
        """Return concise guidance text to emulate temperature behavior via prompt style."""
        try:
            t = float(temperature)
        except Exception:
            return ""
        if t <= 0.0:
            return "Be strictly deterministic and concise. Avoid creativity; pick the most likely answer."
        if t <= 0.3:
            return "Be focused and precise. Prefer the most probable phrasing; minimize variation."
        if t <= 0.6:
            return "Balance determinism with small variation. Provide clear, relevant content."
        if t <= 0.8:
            return "Allow some creativity while staying relevant and structured."
        if t <= 1.0:
            return "Increase diversity slightly; offer alternative ideas if helpful."
        if t <= 1.5:
            return "Be creative; explore multiple directions while keeping coherence."
        return "Be very creative and exploratory; accept higher variance, but avoid illogical statements."
    
    def _get_project_timestamp(self, project_dir: str) -> str:
        """Get consistent timestamp from project directory name"""
        return os.path.basename(project_dir)
    
    def execute_sequential_phase(self, task_id: str, agent_name: str, agent_output: str, project_dir: str) -> Dict[str, Any]:
        """
        Execute a sequential phase where agent reads previous documents and builds upon them
        
        Args:
            task_id: Task identifier
            agent_name: Name of the current agent
            agent_output: Output from the agent
            project_dir: Project directory path
            
        Returns:
            Execution results with created files
        """
        try:
            logger.info(f"Executing sequential phase for {agent_name} agent")
            
            if agent_name not in self.document_templates:
                logger.warning(f"No document template found for {agent_name}")
                return {
                    'status': 'skipped',
                    'reason': f'No document template for {agent_name}'
                }
            
            template = self.document_templates[agent_name]
            executor_func = template['executor']
            
            # Read previous documents
            previous_documents = self._read_previous_documents(project_dir, template['input_files'])
            
            # Get agent prompt from AgentManager
            agent_prompt = self._get_agent_prompt(agent_name)
            # Prepend optional handoff prompt configured for this agent
            try:
                from src.routes.bmad_api import agent_manager as _am
                handoff = _am.get_handoff_prompt(agent_name)
                if handoff:
                    agent_prompt = f"{handoff}\n\n" + (agent_prompt or "")
            except Exception:
                pass

            # Get agent instructions from AgentManager
            agent_instructions = self._get_agent_instructions(agent_name)
            if agent_instructions:
                agent_prompt = f"{agent_prompt}\n\n=== AGENT INSTRUCTIONS ===\n{agent_instructions}"

            # Inject temperature guidance block into the agent prompt if available
            try:
                temp = self._get_agent_temperature(task_id, agent_name)
                if temp is not None:
                    guidance = self._temperature_guidance(temp)
                    if guidance:
                        agent_prompt = f"{agent_prompt}\n\n=== SAMPLING BEHAVIOR ===\n{guidance}"
            except Exception:
                pass
            
            # Inject memory block (summary + latest JSON + active-file hint) into the agent prompt
            try:
                memory_block = self._build_memory_block(task_id, agent_name)
                if memory_block:
                    agent_prompt = f"{agent_prompt}{memory_block}"
            except Exception:
                pass

            # Execute the agent-specific phase with the (possibly augmented) agent prompt
            # Get timeout configuration from timeout config
            from src.config.timeout_config import get_agent_timeout_config
            timeout_config = get_agent_timeout_config(agent_name)
            max_retries = timeout_config.get('max_retries', 2)
            
            # Special handling for directory structure agents - they need agent_name
            if agent_name in ['directory_structure', 'io8directory_structure']:
                result = executor_func(task_id, agent_output, project_dir, previous_documents, agent_prompt, agent_name=agent_name)
            else:
                result = executor_func(task_id, agent_output, project_dir, previous_documents, agent_prompt)

            # Log outcome based on returned status to avoid misleading "completed" messages
            try:
                status = (result or {}).get('status', '')
                if status == 'success':
                    logger.info(f"{agent_name} sequential phase completed successfully")
                elif status == 'partial':
                    remaining = (result or {}).get('remaining_subtasks', '')
                    logger.warning(f"{agent_name} sequential phase ended partial; remaining_subtasks={remaining}")
                elif status == 'failed':
                    err = (result or {}).get('error', '')
                    logger.error(f"{agent_name} sequential phase failed: {err}")
                elif status == 'error':
                    err = (result or {}).get('error', '')
                    logger.error(f"{agent_name} sequential phase error: {err}")
                else:
                    logger.info(f"{agent_name} sequential phase finished with status='{status or 'unknown'}'")
            except Exception:
                pass

            return result
            
        except Exception as e:
            logger.error(f"Sequential phase failed for {agent_name}: {e}")
            # Return a more detailed error response
            return {
                'status': 'failed',
                'error': str(e),
                'agent': agent_name,
                'task_id': task_id
            }
    
    def _read_previous_documents(self, project_dir: str, input_files: List[str]) -> Dict[str, str]:
        """Read previous documents that this agent needs to reference"""
        documents = {}
        
        for file_name in input_files:
            file_path = os.path.join(project_dir, file_name)
            if os.path.exists(file_path):
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        documents[file_name] = f.read()
                    logger.info(f"Read previous document: {file_name}")
                except Exception as e:
                    logger.error(f"Error reading {file_name}: {e}")
            else:
                logger.warning(f"Previous document not found: {file_name}")
        
        return documents
    
    def _merge_sureai_directories(self, bmad_sureai_path: str, base_sureai_path: str):
        """
        Carefully merge BMAD .sureai directory with base project .sureai directory.
        Preserves all base project files and only adds BMAD-specific files.
        """
        try:
            import shutil
            
            # Ensure base .sureai directory exists
            os.makedirs(base_sureai_path, exist_ok=True)
            
            # Get list of predefined documents that should never be overwritten
            protected_files = {
                'analysis_document.md',
                'requirements_document.md',
                'architecture_document.md', 
                'tech_stack_document.md',
                'prd_document.md',
                'project_plan.md',
                '.directory_structure.md',
                '.io8codermaster_breakdown.md',
                '.io8codermaster_plan.md'
            }
            
            # Walk through BMAD .sureai backup and selectively restore
            for root, dirs, files in os.walk(bmad_sureai_path):
                # Calculate relative path from bmad_sureai_path
                rel_path = os.path.relpath(root, bmad_sureai_path)
                target_dir = os.path.join(base_sureai_path, rel_path) if rel_path != '.' else base_sureai_path
                
                # Create target directory if it doesn't exist
                os.makedirs(target_dir, exist_ok=True)
                
                # Copy files, but skip protected predefined documents
                for file in files:
                    src_file = os.path.join(root, file)
                    dst_file = os.path.join(target_dir, file)
                    
                    # Check if this is a protected file
                    if file in protected_files:
                        if os.path.exists(dst_file):
                            logger.info(f"🔒 Preserving base project file: {file}")
                            continue
                        else:
                            logger.info(f"⚠️ Base project missing {file}, copying from BMAD backup")
                    
                    # For non-protected files or missing protected files, copy from BMAD backup
                    if not os.path.exists(dst_file):
                        shutil.copy2(src_file, dst_file)
                        logger.info(f"✅ Restored BMAD file: {os.path.join(rel_path, file) if rel_path != '.' else file}")
            
            logger.info("✅ Successfully merged .sureai directories preserving base project files")
            
        except Exception as e:
            logger.error(f"❌ Failed to merge .sureai directories: {e}")
            
    def _remove_placeholder_files(self, project_dir: str) -> List[str]:
        """Remove files that contain only placeholder content to prevent overwriting real content.
        Returns list of files removed.
        """
        removed_files = []
        
        # Only run this if base project cloning was attempted - check for base project indicators
        sureai_dir = os.path.join(project_dir, '.sureai')
        if not os.path.exists(sureai_dir):
            return removed_files
            
        # Look for signs this is a base project (multiple predefined documents)
        predefined_docs = [
            'analysis_document.md',
            'requirements_document.md', 
            'architecture_document.md',
            'tech_stack_document.md',
            'prd_document.md',
            'project_plan.md'
        ]
        
        found_predefined = 0
        base_project_location = None
        
        # Check root .sureai first
        for doc in predefined_docs:
            doc_path = os.path.join(sureai_dir, doc)
            if os.path.exists(doc_path):
                found_predefined += 1
        
        if found_predefined >= 3:
            base_project_location = sureai_dir
        else:
            # Check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            found_predefined = found_count
                            base_project_location = sub_sureai
                            break
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            if os.path.exists(doc_path):
                found_predefined += 1
        
        if found_predefined < 3:
            logger.info(f"🔍 Not enough predefined docs found ({found_predefined}) - skipping placeholder removal")
            return removed_files
            
        logger.info(f"🔍 Found {found_predefined} predefined docs - checking for placeholder overwrites")
        
        # Check all files recursively for placeholder content
        placeholder_indicators = [
            'Placeholder - to be implemented by Developer agent',
            'Placeholder - DevOps will fill this later',
            '<!-- Placeholder - to be implemented by Developer agent -->',
            '/* Placeholder - to be implemented by Developer agent */',
            '// Placeholder - to be implemented by Developer agent',
            '# Placeholder - to be implemented by Developer agent'
        ]
        
        try:
            for root, dirs, files in os.walk(project_dir):
                # Skip .git directories
                dirs[:] = [d for d in dirs if d != '.git']
                
                for file in files:
                    file_path = os.path.join(root, file)
                    rel_path = os.path.relpath(file_path, project_dir)
                    
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read().strip()
                            
                        # Check if file contains only placeholder content
                        is_placeholder = any(indicator in content for indicator in placeholder_indicators)
                        is_only_placeholder = content in placeholder_indicators or len(content) < 100 and is_placeholder
                        
                        if is_only_placeholder:
                            os.remove(file_path)
                            removed_files.append(rel_path)
                            logger.info(f"🗑️ Removed placeholder file: {rel_path}")
                            
                    except Exception as e:
                        logger.debug(f"Could not check file {rel_path}: {e}")
                        
        except Exception as e:
            logger.warning(f"Error during placeholder removal: {e}")
            
        logger.info(f"🧹 Removed {len(removed_files)} placeholder files")
        return removed_files
    
    def _execute_directory_structure_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "", agent_name: str = "directory_structure") -> Dict[str, Any]:
        """Execute directory structure phase - create project structure"""
        try:
            # Base project cloning is no longer required for io8 workflows
            base_project_cloned = False
            try:
                from src.core.task_manager import TaskManager
                import subprocess
                tm = TaskManager()
                state = tm.get_task_state(task_id)
                
                logger.info(f"🔍 Checking base project configuration for agent: {agent_name}")
                logger.info(f"📊 Task state available: {state is not None}")
                
                # Explicitly skip any base project cloning logic for io8 workflows
                if state:
                    logger.info("⏭️ Skipping base project cloning - disabled for io8 workflows")
                            
            except Exception as e:
                logger.warning(f"⚠️ Base project check failed: {e}")
            
            # Detect base project .sureai and prefer that as working directory for outputs
            effective_working_dir = project_dir
            try:
                base_project_sureai_path = self._detect_base_project_sureai_location(project_dir)
                if base_project_sureai_path:
                    effective_working_dir = os.path.dirname(base_project_sureai_path)
                    logger.info(f"📁 Using base project working directory for {agent_name}: {effective_working_dir}")
            except Exception:
                pass

            # Step 1: Create user-prompt-specific directory structure agent prompt file
            # Use the actual project directory name instead of task_id for consistent naming
            project_dir_name = os.path.basename(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            directory_agent_file = f".sureai/.directory_structure_agent_{user_prompt_slug}_{project_dir_name}.md"
            directory_structure_file = f".sureai/.directory_structure_{user_prompt_slug}_{project_dir_name}.md"
            
            # Create the specific directory structure agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific directory structure agent prompt file for this user prompt
2. Create the file: {directory_agent_file}
3. This file should contain the directory structure agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Directory structure methodology specific to this project type
   - Project organization approach for this particular user request
   - File structure planning framework
   - Configuration file strategy
   - Customized directory structure workflow for this project
5. Include all necessary directory and file organization instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent steps

IMPORTANT: Write the actual directory structure agent prompt content in the file, not just create an empty file.

Create the directory structure agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            structure_cli = self._get_cli_client(task_id, agent_name)
            before_agent = self._snapshot_tree(effective_working_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, effective_working_dir, structure_cli)
            agent_file_response = structure_cli.generate_single_response(injected_agent_prompt, working_dir=effective_working_dir, agent_name=agent_name)
            after_agent = self._snapshot_tree(effective_working_dir)
            self._log_created_paths('Python Parser' if getattr(structure_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_agent - before_agent)))
            
            # Step 2: Create user-prompt-specific directory structure specification file
            
            # If base project was cloned, modify the directory structure creation approach
            if base_project_cloned:
                # Base project already exists, just ensure required BMAD directories
                create_structure_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILE:
@{directory_agent_file}

BASE PROJECT CLONED:
A base project has been cloned to this directory. The existing structure should be preserved.

INSTRUCTIONS:
1. Read the directory structure agent prompt from the reference file above
2. Create a directory structure file documenting the current project structure: {directory_structure_file}
3. **CRITICAL: DO NOT create any directories or files - ONLY document existing structure**
4. **DO NOT modify existing project files or structure**
5. **DO NOT create backend/ or frontend/ directories if they already exist**
6. **NEVER create any predefined documents (analysis_document.md, requirements_document.md, etc.)**
7. Document the complete directory structure including both base project files and BMAD directories
8. The file should contain:
   - Complete directory tree structure of the existing project
   - All existing directories and files from the base project
   - BMAD-specific directories that were added
   - Explanation of how the base project structure integrates with BMAD workflow

IMPORTANT: Document the actual existing structure, don't create new project files. Preserve all existing predefined documents from the base project.

Create/update the directory structure documentation file:
"""
            else:
                # Standard directory structure creation
                create_structure_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILE:
@{directory_agent_file}

INSTRUCTIONS:
1. Read the directory structure agent prompt from the reference file above
2. Create a specific directory structure file for this user prompt
3. Create the file: {directory_structure_file}
4. This file should contain the exact directory structure needed for this specific project
5. Write detailed content in the file including:
   - Complete directory tree structure for this specific project
   - All necessary directories and files based on the user prompt
   - Specific file names and paths
   - Customizations for this particular project type
6. Follow the base directory structure pattern but customize it for this specific project
7. Include all directories: .io8project/, .sureai/, backend/, frontend/
8. Include all configuration files: deployment_config.yml, Dockerfile.backend, Dockerfile.frontend, docker-compose.yml, nginx.conf
9. Make the content specific to the user's request

IMPORTANT: Write the actual directory structure content in the file, not just create an empty file.

Create the directory structure specification file with detailed content:
"""
            
            # Select CLI for this agent and generate the spec file
            cli_client = self._get_cli_client(task_id, agent_name)
            # Log the complete prompt being sent to the CLI
            self._log_prompt_to_gemini("directory_structure_file_creation", create_structure_file_prompt, agent_prompt, previous_docs)
            structure_file_response = cli_client.generate_single_response(create_structure_file_prompt, working_dir=effective_working_dir, agent_name=agent_name)

            # Ensure the spec file exists; if CLI didn't create it (e.g., SureCli), write it ourselves
            created_spec_path = os.path.join(effective_working_dir, directory_structure_file)
            if not os.path.exists(created_spec_path):
                try:
                    sureai_dir = os.path.dirname(created_spec_path)
                    os.makedirs(sureai_dir, exist_ok=True)
                    # Normalize possible JSON/fenced content
                    normalized_spec = structure_file_response or ''
                    try:
                        txt = (normalized_spec or '').strip()
                        if txt.startswith('```'):
                            # unwrap fenced block
                            parts = txt.strip('`\n').split('\n', 1)
                            if len(parts) == 2 and parts[0].strip().lower() == 'json':
                                txt = parts[1]
                        if txt.startswith('{') and txt.endswith('}'):
                            import json as _json
                            try:
                                j = _json.loads(txt)
                                if isinstance(j, dict):
                                    normalized_spec = j.get('directory_structure') or normalized_spec
                            except Exception:
                                pass
                    except Exception:
                        pass
                    with open(created_spec_path, 'w', encoding='utf-8') as f:
                        f.write(normalized_spec)
                    logger.info(f"Wrote directory structure spec via Python to {created_spec_path}")
                except Exception as e:
                    logger.warning(f"Could not write spec file to {created_spec_path}: {e}")
            
            # Step 3: Now create the actual directory structure by referring to the created files
            if base_project_cloned:
                # Just document BMAD directories - do NOT create any files or directories
                create_structure_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

BASE PROJECT STATUS:
A base project has been successfully cloned. Existing project structure is preserved.

REFERENCE FILES:
@{directory_agent_file}
@{directory_structure_file}

INSTRUCTIONS:
1. Read the directory structure agent prompt and documentation from the reference files above
2. **CRITICAL: DO NOT create any directories or files**
3. **DO NOT run any mkdir, touch, or file creation commands**
4. **ONLY document and describe the existing structure**
5. **NEVER modify any existing files or directories**
6. **NEVER create backend/ or frontend/ directories if they already exist**
7. **NEVER create any predefined documents**

IMPORTANT: This is a documentation-only task. Do not create or modify any files or directories.

Document the existing base project structure:
"""
            else:
                # Standard directory structure creation
                create_structure_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{directory_agent_file}
@{directory_structure_file}

INSTRUCTIONS:
1. Read the directory structure agent prompt and specification from the reference files above
2. Create ONLY the directory structure for the project based on that specification (no application code yet)
3. Follow the EXACT structure specified in the reference file
4. Create required directories and placeholder files ONLY:
   - `.io8project/` metadata directory (with empty placeholders for .state.json and project_metadata.json)
   - `.sureai/` directory for agent outputs and documents
   - `backend/` and `frontend/` directories (with `.gitkeep` placeholders to keep empty folders tracked)
   - Root-level configuration files as EMPTY placeholders with a single comment line (deployment_config.yml, Dockerfile.backend, Dockerfile.frontend, docker-compose.yml, nginx.conf). Do NOT add real config content here; DevOps will fill these later.

5. CRITICAL: Do NOT create any predefined documents (analysis_document.md, requirements_document.md, architecture_document.md, tech_stack_document.md, prd_document.md, project_plan.md, tasks_list.md, sprint_plan.md). These will be created by their respective agents.

6. Do NOT write any application code in any file. Your output at this step must only create folders and blank/placeholder files.

IMPORTANT: Create the actual directories and placeholder files using your file system access. Do not output a tree; perform the creation operations.

Create the directory structure based on the reference files:
"""
            
            # If using SureCli, Python must create folders/files from the spec
            if getattr(cli_client, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                try:
                    before = self._snapshot_tree(project_dir)
                    # Check if this is a base project before creating structure
                    sureai_dir = os.path.join(project_dir, '.sureai')
                    has_base_project = False
                    base_project_location = None
                    
                    # First check root .sureai
                    if os.path.exists(sureai_dir):
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                        if found_count >= 3:
                            has_base_project = True
                            base_project_location = sureai_dir
                    
                    # If not found in root, check subdirectories for base project .sureai
                    if not has_base_project:
                        for root, dirs, files in os.walk(project_dir):
                            if '.sureai' in dirs:
                                sub_sureai = os.path.join(root, '.sureai')
                                if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                                    predefined_docs = [
                                        'analysis_document.md', 'requirements_document.md',
                                        'architecture_document.md', 'tech_stack_document.md',
                                        'prd_document.md', 'project_plan.md'
                                    ]
                                    found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                                    if found_count >= 3:
                                        has_base_project = True
                                        base_project_location = sub_sureai
                                        break
                            # Don't recurse too deep
                            if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                                break
                                
                    logger.info(f"🔍 Enhanced base project detection: has_base_project={has_base_project}, location={base_project_location}")
                    
                    # Skip structure creation if base project detected
                    if base_project_cloned or has_base_project:
                        logger.info("🔒 Base project detected - Skipping Python structure creation for SureCli")
                        created_paths = []
                        response = "Base project detected - no directories or files created, only documentation updated"
                    else:
                        # Read the spec content and create structure
                        spec_text = ''
                        try:
                            with open(created_spec_path, 'r', encoding='utf-8') as f:
                                spec_text = f.read()
                        except Exception as e:
                            logger.warning(f"Could not read spec at {created_spec_path}: {e}")
                        created_paths = self._create_structure_from_spec(project_dir, spec_text, base_project_cloned)
                        response = "Python-created directory structure from SureCli spec"
                    
                    after = self._snapshot_tree(project_dir)
                    delta = sorted(list(after - before))
                    self._log_created_paths('Python Parser', delta)
                except Exception as e:
                    logger.error(f"SureCli directory creation failed: {e}")
                    response = f"Error generating response: {e}"
            else:
                # Log the complete prompt being sent to Gemini CLI and let CLI create structure
                self._log_prompt_to_gemini("directory_structure_creation", create_structure_prompt, agent_prompt, previous_docs)
                before = self._snapshot_tree(project_dir)
                response = self._get_cli_client(task_id, agent_name).generate_single_response(create_structure_prompt, working_dir=project_dir, agent_name=agent_name)
                after = self._snapshot_tree(project_dir)
                delta = sorted(list(after - before))
                self._log_created_paths('Gemini CLI', delta)

            # Capture a small filesystem snapshot for diagnostics
            created_paths = created_paths if 'created_paths' in locals() else []
            try:
                for root, dirs, files in os.walk(project_dir):
                    rel_root = os.path.relpath(root, project_dir)
                    if rel_root == ".":
                        rel_root = ""
                    for d in dirs:
                        created_paths.append(os.path.join(rel_root, d).replace("\\", "/"))
                    for f in files:
                        created_paths.append(os.path.join(rel_root, f).replace("\\", "/"))
                    if len(created_paths) > 120:
                        break
                logger.info(f"Directory structure snapshot (first {min(len(created_paths), 120)} entries):")
                for p in created_paths[:120]:
                    logger.info(f" - {p}")
            except Exception as e:
                logger.warning(f"Failed to generate filesystem snapshot: {e}")

            # Enforce directory-only rule: strip any accidental code written in backend/ or frontend/ (unless base project was cloned)
            # CRITICAL: Never sanitize if base project was cloned to preserve existing files
            if not base_project_cloned:
                try:
                    sanitized = self._sanitize_code_directories(project_dir)
                    if sanitized:
                        logger.info("Sanitized files to enforce directory-only creation (replaced content with placeholders):")
                        for path in sanitized[:50]:
                            logger.info(f" - {path}")
                except Exception as e:
                    logger.warning(f"Failed to sanitize code directories: {e}")
            else:
                logger.info("🔒 Skipping directory sanitization - base project cloned, preserving existing files")
                
                # For base projects, remove any files that were accidentally overwritten with placeholders
                try:
                    removed_placeholders = self._remove_placeholder_files(project_dir)
                    if removed_placeholders:
                        logger.info(f"🧹 Removed {len(removed_placeholders)} placeholder files that overwrote base project content")
                except Exception as e:
                    logger.warning(f"Failed to remove placeholder files: {e}")
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR DIRECTORY STRUCTURE ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(cli_client, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            status_message = 'Directory structure created with base project' if base_project_cloned else 'Directory structure created'
            logger.info(f"Directory structure phase completed - Created by: {source} - Base project cloned: {base_project_cloned}")
            
            return {
                'status': 'success',
                'response': response,
                'message': status_message,
                'structure_file': directory_structure_file,
                'files_created': created_paths,
                'base_project_cloned': base_project_cloned
            }
            
        except Exception as e:
            logger.error(f"Error in directory structure phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _sanitize_code_directories(self, project_dir: str) -> List[str]:
        """Ensure backend/ and frontend/ contain no real code at this phase by replacing contents with placeholders.
        Only applies to non-base-project scenarios where directory agent may accidentally create code.
        Returns list of files modified.
        """
        modified: List[str] = []
        
        # First check if this is a base project by looking for predefined documents
        sureai_dir = os.path.join(project_dir, '.sureai')
        has_base_project = False
        
        # Check root .sureai first
        if os.path.exists(sureai_dir):
            predefined_docs = [
                'analysis_document.md',
                'requirements_document.md', 
                'architecture_document.md',
                'tech_stack_document.md',
                'prd_document.md',
                'project_plan.md'
            ]
            
            found_predefined = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
            if found_predefined >= 3:
                has_base_project = True
        
        # If not found in root, check subdirectories for base project .sureai
        if not has_base_project:
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md',
                            'requirements_document.md', 
                            'architecture_document.md',
                            'tech_stack_document.md',
                            'prd_document.md',
                            'project_plan.md'
                        ]
                        found_predefined = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_predefined >= 3:
                            has_base_project = True
                            break
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
        
        if has_base_project:
            logger.info(f"🔒 Skipping code directory sanitization - detected base project")
            return modified
        
        code_dirs = [os.path.join(project_dir, 'backend'), os.path.join(project_dir, 'frontend')]
        placeholder_map = {
            '.py': '# Placeholder - to be implemented by Developer agent\n',
            '.js': '// Placeholder - to be implemented by Developer agent\n',
            '.ts': '// Placeholder - to be implemented by Developer agent\n',
            '.tsx': '// Placeholder - to be implemented by Developer agent\n',
            '.jsx': '// Placeholder - to be implemented by Developer agent\n',
            '.html': '<!-- Placeholder - to be implemented by Developer agent -->\n',
            '.css': '/* Placeholder - to be implemented by Developer agent */\n',
            '.scss': '/* Placeholder - to be implemented by Developer agent */\n',
            '.go': '// Placeholder - to be implemented by Developer agent\n',
            '.java': '// Placeholder - to be implemented by Developer agent\n',
            '.kt': '// Placeholder - to be implemented by Developer agent\n',
            '.rb': '# Placeholder - to be implemented by Developer agent\n',
            '.php': '<?php /* Placeholder - to be implemented by Developer agent */ ?>\n',
            '.cs': '// Placeholder - to be implemented by Developer agent\n',
            '.swift': '// Placeholder - to be implemented by Developer agent\n',
            '.rs': '// Placeholder - to be implemented by Developer agent\n'
        }
        for cdir in code_dirs:
            if not os.path.isdir(cdir):
                continue
            for root, _, files in os.walk(cdir):
                for fname in files:
                    if fname == '.gitkeep':
                        continue
                    fpath = os.path.join(root, fname)
                    try:
                        ext = os.path.splitext(fname)[1].lower()
                        with open(fpath, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        if content.strip():
                            placeholder = placeholder_map.get(ext, 'Placeholder - to be implemented by Developer agent\n')
                            with open(fpath, 'w', encoding='utf-8') as f:
                                f.write(placeholder)
                            modified.append(os.path.relpath(fpath, project_dir))
                    except Exception:
                        # If read fails, skip
                        continue
        # Ensure empty folders have .gitkeep
        for cdir in code_dirs:
            if os.path.isdir(cdir):
                for root, dirs, files in os.walk(cdir):
                    if not files:
                        try:
                            keep_path = os.path.join(root, '.gitkeep')
                            if not os.path.exists(keep_path):
                                open(keep_path, 'a').close()
                        except Exception:
                            pass
        return modified

    def _snapshot_tree(self, project_dir: str) -> set:
        """Return a set of relative file and directory paths for the project tree (bounded)."""
        snapshot: set = set()
        try:
            for root, dirs, files in os.walk(project_dir):
                rel_root = os.path.relpath(root, project_dir)
                if rel_root == ".":
                    rel_root = ""
                for d in dirs:
                    snapshot.add(os.path.join(rel_root, d).replace("\\", "/"))
                for f in files:
                    snapshot.add(os.path.join(rel_root, f).replace("\\", "/"))
                if len(snapshot) > 2000:
                    break
        except Exception:
            pass
        return snapshot

    def _log_created_paths(self, source_label: str, created_paths: List[str]):
        try:
            if not created_paths:
                logger.info(f"[{source_label}] No new files or directories detected")
                return
            logger.info(f"[{source_label}] Created {len(created_paths)} items:")
            for p in created_paths[:200]:
                logger.info(f"[{source_label}] Created: {p}")
            if len(created_paths) > 200:
                logger.info(f"[{source_label}] ... and {len(created_paths) - 200} more")
        except Exception:
            pass

    def _inject_document_contents(self, prompt: str, project_dir: str, cli_client) -> str:
        """
        When using SureCli, inject actual document contents instead of @ references
        since google.generativeai can't read files directly.
        This includes both agent-specific prompt files and previous agent documents.
        Implements legacy filename fallback for io8 workflow compatibility.
        """
        if getattr(cli_client, '__class__', type('X', (), {})).__name__ != 'SureCliClient':
            logger.info(f"[Python Parser] Skipping injection - using {getattr(cli_client, '__class__', type('X', (), {})).__name__}")
            return prompt  # No injection needed for CLI clients
        
        # Find all @document references in the prompt (including agent files and .sureai documents)
        import re
        doc_refs = re.findall(r'@([^\s\n]+\.md)', prompt)
        
        if not doc_refs:
            logger.info(f"[Python Parser] No @ references found in prompt")
            return prompt
        
        logger.info(f"[Python Parser] Found {len(doc_refs)} @ references: {doc_refs}")
        logger.info(f"[Python Parser] Injecting document contents for SureCli")
        
        # Define legacy filename mappings for io8 workflow compatibility
        legacy_mappings = {
            ".io8codermaster_breakdown.md": ".io8coder_breakdown.md",
            ".io8codermaster_plan.md": ".io8coder_plan.md",
            ".io8codermaster_agent_": ".io8coder_agent_",  # For agent files
        }
        
        # Read and inject each document
        for doc_ref in doc_refs:
            doc_path = os.path.join(project_dir, doc_ref)
            content_found = False
            
            try:
                # First try the specified filename
                if os.path.exists(doc_path):
                    with open(doc_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    # Replace @doc_ref with actual content
                    old_prompt = prompt
                    prompt = prompt.replace(f"@{doc_ref}", f"=== {doc_ref} ===\n{content}\n=== END {doc_ref} ===")
                    if old_prompt != prompt:
                        logger.info(f"[Python Parser] Successfully injected content from {doc_ref} ({len(content)} chars)")
                        content_found = True
                    else:
                        logger.warning(f"[Python Parser] Failed to replace @{doc_ref} in prompt")
                        content_found = True  # Still consider it found even if replacement failed
                
                # If not found, try legacy naming for common io8 files
                if not content_found:
                    legacy_name = doc_ref
                    # Apply legacy mappings
                    for new_name, old_name in legacy_mappings.items():
                        if new_name in doc_ref:
                            legacy_name = doc_ref.replace(new_name, old_name)
                            break
                    
                    legacy_path = os.path.join(project_dir, legacy_name)
                    
                    if os.path.exists(legacy_path):
                        with open(legacy_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                        # Replace @doc_ref with actual content (using original reference name)
                        old_prompt = prompt
                        prompt = prompt.replace(f"@{doc_ref}", f"=== {doc_ref} ===\n{content}\n=== END {doc_ref} ===")
                        if old_prompt != prompt:
                            logger.info(f"[Python Parser] Successfully injected legacy content from {legacy_name} as {doc_ref} ({len(content)} chars)")
                            content_found = True
                        else:
                            logger.warning(f"[Python Parser] Failed to replace @{doc_ref} in prompt (legacy file)")
                            content_found = True  # Still consider it found even if replacement failed
                
                # If still not found, mark as not found
                if not content_found:
                    logger.warning(f"[Python Parser] Document not found: {doc_path}")
                    prompt = prompt.replace(f"@{doc_ref}", f"=== {doc_ref} (NOT FOUND) ===")
                    
            except Exception as e:
                logger.warning(f"[Python Parser] Failed to read {doc_ref}: {e}")
                prompt = prompt.replace(f"@{doc_ref}", f"=== {doc_ref} (ERROR: {e}) ===")
        
        # Log final prompt length to verify injection
        logger.info(f"[Python Parser] Final injected prompt length: {len(prompt)} characters")
        return prompt

    def _create_structure_from_spec(self, project_dir: str, spec_text: str, base_project_cloned: bool = False) -> List[str]:
        """
        Create the exact directory structure as per directory agent prompt.
        Creates only the mandatory BMAD structure without modifying existing base project files.
        """
        created: List[str] = []
        
        try:
            # Check if this is a base project by looking for existing predefined documents
            sureai_dir = os.path.join(project_dir, '.sureai')
            has_base_project = False
            base_project_location = None
            
            # First check root .sureai
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md',
                    'requirements_document.md',
                    'architecture_document.md',
                    'tech_stack_document.md',
                    'prd_document.md',
                    'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    has_base_project = True
                    base_project_location = sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            if not has_base_project:
                for root, dirs, files in os.walk(project_dir):
                    if '.sureai' in dirs:
                        sub_sureai = os.path.join(root, '.sureai')
                        if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                            predefined_docs = [
                                'analysis_document.md',
                                'requirements_document.md',
                                'architecture_document.md',
                                'tech_stack_document.md',
                                'prd_document.md',
                                'project_plan.md'
                            ]
                            found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                            if found_count >= 3:
                                has_base_project = True
                                base_project_location = sub_sureai
                                break
                    # Don't recurse too deep
                    if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                        break
                        
            logger.info(f"🔍 Base project detection: has_base_project={has_base_project}, base_project_cloned={base_project_cloned}, location={base_project_location}")
            
            # If base project is detected, be extra careful
            if base_project_cloned or has_base_project:
                logger.info("🔒 Base project detected - SKIPPING all directory and file creation")
                logger.info("📁 Only documenting existing structure - no files will be created")
                return created  # Return early, don't create anything
            
            # Create main BMAD directories (but don't overwrite existing backend/frontend from base project)
            main_dirs = ['.io8project', '.sureai', '.sureai/uploads']
            
            # Only create backend/frontend if they don't already exist (preserve base project structure)
            for dir_name in ['backend', 'frontend']:
                dir_path = os.path.join(project_dir, dir_name)
                if not os.path.exists(dir_path):
                    main_dirs.append(dir_name)
                else:
                    logger.info(f"🔒 Preserving existing {dir_name}/ directory from base project")
            
            for dir_path in main_dirs:
                full_path = os.path.join(project_dir, dir_path)
                os.makedirs(full_path, exist_ok=True)
                created.append(dir_path)
                logger.info(f"Created directory: {dir_path}")
            
            # Create .io8project files only if they don't exist
            state_file = os.path.join(project_dir, '.io8project', '.state.json')
            if not os.path.exists(state_file):
                with open(state_file, 'w', encoding='utf-8') as f:
                    f.write('{"status": "initialized"}')
                created.append('.io8project/.state.json')
            
            metadata_file = os.path.join(project_dir, '.io8project', 'project_metadata.json')
            if not os.path.exists(metadata_file):
                with open(metadata_file, 'w', encoding='utf-8') as f:
                    f.write('{"project": "metadata"}')
                created.append('.io8project/project_metadata.json')
            
            # Create root level config files (empty placeholders) - only if they don't exist
            config_files = [
                'deployment_config.yml',
                'Dockerfile.backend', 
                'Dockerfile.frontend',
                'docker-compose.yml',
                'nginx.conf'
            ]
            for config_file in config_files:
                file_path = os.path.join(project_dir, config_file)
                if not os.path.exists(file_path):
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write('# Placeholder - DevOps will fill this later\n')
                    created.append(config_file)
                    logger.info(f"Created config file: {config_file}")
                else:
                    logger.info(f"🔒 Preserving existing config file: {config_file}")
            
            # Add .gitkeep to backend and frontend directories only if they are empty and we created them
            for dir_name in ['backend', 'frontend']:
                dir_path = os.path.join(project_dir, dir_name)
                if os.path.exists(dir_path):
                    # Check if directory is empty (ignore .gitkeep itself)
                    dir_contents = [f for f in os.listdir(dir_path) if f != '.gitkeep']
                    if not dir_contents:  # Directory is empty
                        gitkeep_path = os.path.join(dir_path, '.gitkeep')
                        if not os.path.exists(gitkeep_path):
                            with open(gitkeep_path, 'w', encoding='utf-8') as f:
                                f.write('')
                            created.append(f"{dir_name}/.gitkeep")
                            logger.info(f"Added .gitkeep to empty {dir_name}/ directory")
                    else:
                        logger.info(f"🔒 Preserving existing content in {dir_name}/ directory ({len(dir_contents)} items)")
            
            logger.info(f"Directory structure created successfully with {len(created)} items")
            
            # CRITICAL: Ensure no predefined documents are accidentally created
            predefined_docs = [
                'analysis_document.md',
                'requirements_document.md',
                'architecture_document.md',
                'tech_stack_document.md', 
                'prd_document.md',
                'project_plan.md',
                'tasks_list.md',
                'sprint_plan.md'
            ]
            
            for doc in predefined_docs:
                doc_path = os.path.join(project_dir, '.sureai', doc)
                if os.path.exists(doc_path):
                    # Check if it's just a placeholder - if so, remove it
                    try:
                        with open(doc_path, 'r', encoding='utf-8') as f:
                            content = f.read().strip()
                        if content == 'Placeholder - to be implemented by Developer agent' or content == '':
                            os.remove(doc_path)
                            logger.info(f"🗑️ Removed accidentally created placeholder: {doc}")
                        else:
                            logger.info(f"🔒 Preserving existing predefined document: {doc}")
                    except Exception as e:
                        logger.warning(f"Could not check predefined document {doc}: {e}")
            
        except Exception as e:
            logger.warning(f"Failed to parse directory spec: {e}")
        return created

    def _execute_io8codermaster_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute io8code Master phase - create breakdown and plan documents"""
        try:
            # Detect base project location first
            base_project_sureai_path = self._detect_base_project_sureai_location(project_dir)
            effective_working_dir = project_dir
            
            if base_project_sureai_path:
                # Use base project directory as working directory for agent files
                effective_working_dir = os.path.dirname(base_project_sureai_path)
                logger.info(f"📁 Using base project working directory: {effective_working_dir}")
            else:
                logger.info(f"📁 Using root working directory: {effective_working_dir}")
            
            # Step 1: Create user-prompt-specific io8codermaster agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            bmad_agent_file = f".sureai/.io8codermaster_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific io8codermaster agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific io8codermaster agent prompt file for this user prompt
2. Create the file: {bmad_agent_file}
3. This file must contain ONLY the io8codermaster agent prompt customized for this specific project. Do not include breakdown or plan content here.
4. Include:
   - io8codermaster analysis instructions specific to this project type
   - Breakdown methodology for this particular user request
   - Planning approach tailored to the project requirements
   - Specific analysis questions and considerations
   - Customized io8codermaster workflow for this project
5. The content must be actionable and tailored to the user's request and project type.
6. This file will be referenced by subsequent steps to produce separate breakdown and plan files.

IMPORTANT: Write the actual io8codermaster agent prompt content in the file, not just create an empty file.

Create the io8codermaster agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            bmad_cli = self._get_cli_client(task_id, "io8codermaster")
            before = self._snapshot_tree(effective_working_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, effective_working_dir, bmad_cli)
            agent_file_response = bmad_cli.generate_single_response(injected_agent_prompt, working_dir=effective_working_dir, agent_name="io8codermaster")
            after = self._snapshot_tree(effective_working_dir)
            self._log_created_paths('Python Parser' if getattr(bmad_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after - before)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(bmad_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(effective_working_dir, bmad_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            # io8architect common keys
                            response_data.get('architecture') or
                            response_data.get('tech_stack') or
                            # fallback keys used by other agents
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with expected section keys, extract their content
                            if 'architecture' in agent_content and 'tech_stack' in agent_content:
                                breakdown_content = agent_content['architecture']
                                plan_content = agent_content['tech_stack']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            elif 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in markdown code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    # Extract known section content if available
                                    if isinstance(json_data, dict):
                                        if 'architecture' in json_data and 'tech_stack' in json_data:
                                            breakdown_content = json_data['architecture']
                                            plan_content = json_data['tech_stack']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                                        elif 'architecture' in json_data:
                                            breakdown_content = json_data['architecture']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'tech_stack' in json_data:
                                            plan_content = json_data['tech_stack']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract known section content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'architecture' in content_data and 'tech_stack' in content_data:
                                    breakdown_content = content_data['architecture']
                                    plan_content = content_data['tech_stack']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                                elif 'architecture' in content_data:
                                    breakdown_content = content_data['architecture']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'tech_stack' in content_data:
                                    plan_content = content_data['tech_stack']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# io8 Code Master Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard io8codermaster agent with project-specific customizations above.
Refer to the base io8codermaster agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {bmad_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {bmad_agent_file}: {e}")
            
            # Step 2: Now create the breakdown and plan documents by referring to the created agent file
            create_breakdown_plan_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{bmad_agent_file}

INSTRUCTIONS:
1. Read the io8codermaster agent prompt from the reference file above
2. Analyze the user prompt and the agent prompt
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/.io8codermaster_breakdown.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/.io8codermaster_plan.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the breakdown and planning approach defined in the agent prompt
5. Create comprehensive breakdown and plan based on the user prompt
6. Ensure the breakdown and plan are detailed and actionable

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the breakdown and plan documents based on the reference files:
"""
            
            # Log the complete prompt being sent to CLI
            self._log_prompt_to_gemini("io8codermaster_docs_creation", create_breakdown_plan_prompt, agent_prompt, previous_docs)
            
            before_docs = self._snapshot_tree(project_dir)
            bmad_docs_cli = self._get_cli_client(task_id, "io8codermaster")
            # Inject document contents for SureCli
            injected_prompt = self._inject_document_contents(create_breakdown_plan_prompt, project_dir, bmad_docs_cli)
            
            # Log the injected prompt for SureCli
            if getattr(bmad_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                logger.info(f"=== INJECTED PROMPT FOR IO8CODERMASTER (SureCli) ===")
                logger.info(f"INJECTED PROMPT LENGTH: {len(injected_prompt)} characters")
                logger.info("INJECTED PROMPT:")
                logger.info("=" * 80)
                logger.info(injected_prompt)
                logger.info("=" * 80)
            
            response = bmad_docs_cli.generate_single_response(injected_prompt, working_dir=project_dir, agent_name="io8codermaster")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(bmad_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR IO8CODERMASTER ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(bmad_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"io8codermaster phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created io8codermaster breakdown and plan documents'
            }
            
        except Exception as e:
            logger.error(f"Error in io8codermaster phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _execute_io8analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute io8 Analyst phase - create analysis and requirements documents"""
        try:
            # Detect base project location first
            base_project_sureai_path = self._detect_base_project_sureai_location(project_dir)
            effective_working_dir = project_dir
            
            if base_project_sureai_path:
                # Use base project directory as working directory for agent files
                effective_working_dir = os.path.dirname(base_project_sureai_path)
                logger.info(f"📁 Using base project working directory for io8analyst: {effective_working_dir}")
            else:
                logger.info(f"📁 Using root working directory for io8analyst: {effective_working_dir}")
            
            # Step 1: Create user-prompt-specific io8analyst agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            io8analyst_agent_file = f".sureai/.io8analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific io8analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific io8analyst agent prompt file for this user prompt
2. Create the file: {io8analyst_agent_file}
3. This file should contain the io8analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized io8analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual io8analyst agent prompt content in the file, not just create an empty file.

Create the io8analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            io8analyst_cli = self._get_cli_client(task_id, "io8analyst")
            before_a = self._snapshot_tree(effective_working_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, effective_working_dir, io8analyst_cli)
            agent_file_response = io8analyst_cli.generate_single_response(injected_agent_prompt, working_dir=effective_working_dir, agent_name="io8analyst")
            after_a = self._snapshot_tree(effective_working_dir)
            self._log_created_paths('Python Parser' if getattr(io8analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(io8analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(effective_working_dir, io8analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            # io8analyst common keys
                            response_data.get('analysis') or
                            response_data.get('requirements') or
                            # fallback keys used by other agents
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with expected section keys, extract their content
                            if 'analysis' in agent_content and 'requirements' in agent_content:
                                section_a = agent_content['analysis']
                                section_b = agent_content['requirements']
                                if isinstance(section_a, (dict, list)):
                                    section_a = json.dumps(section_a, indent=2)
                                if isinstance(section_b, (dict, list)):
                                    section_b = json.dumps(section_b, indent=2)
                                agent_content = f"{section_a}\n\n{section_b}"
                            elif 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Handle the case where agent_content is a JSON string wrapped in markdown code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                # Extract known section content if available
                                    if isinstance(json_data, dict):
                                        if 'analysis' in json_data and 'requirements' in json_data:
                                            section_a = json_data['analysis']
                                            section_b = json_data['requirements']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(section_a, (dict, list)):
                                                section_a = json.dumps(section_a, indent=2)
                                            if isinstance(section_b, (dict, list)):
                                                section_b = json.dumps(section_b, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{section_a}\n\n{section_b}"
                                        elif 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                                        elif 'analysis' in json_data:
                                            section_a = json_data['analysis']
                                            if isinstance(section_a, (dict, list)):
                                                section_a = json.dumps(section_a, indent=2)
                                            agent_content = section_a
                                        elif 'requirements' in json_data:
                                            section_b = json_data['requirements']
                                            if isinstance(section_b, (dict, list)):
                                                section_b = json.dumps(section_b, indent=2)
                                            agent_content = section_b
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# io8 Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard io8analyst agent with project-specific customizations above.
Refer to the base io8analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {io8analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {io8analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(io8analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{io8analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the io8analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(effective_working_dir)
            io8analyst_docs_cli = self._get_cli_client(task_id, "io8analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, effective_working_dir, io8analyst_docs_cli)
            response = io8analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=effective_working_dir, agent_name="io8analyst")
            after_docs = self._snapshot_tree(effective_working_dir)
            self._log_created_paths('Python Parser' if getattr(io8analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR io8analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(io8analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"io8analyst phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created io8analyst analysis and requirements documents'
            }
            
        except Exception as e:
            logger.error(f"Error in io8analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}
    
    
    def _execute_io8architect_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute io8 Architect phase - create architecture and tech stack documents"""
        try:
            # Detect base project location first
            base_project_sureai_path = self._detect_base_project_sureai_location(project_dir)
            effective_working_dir = project_dir
            
            if base_project_sureai_path:
                # Use base project directory as working directory for agent files
                effective_working_dir = os.path.dirname(base_project_sureai_path)
                logger.info(f"📁 Using base project working directory for io8architect: {effective_working_dir}")
            else:
                logger.info(f"📁 Using root working directory for io8architect: {effective_working_dir}")
            
            # Step 1: Create user-prompt-specific io8architect agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            io8architect_agent_file = f".sureai/.io8architect_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific io8architect agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific io8architect agent prompt file for this user prompt
2. Create the file: {io8architect_agent_file}
3. This file should contain the io8architect agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Architecture design methodology specific to this project type
   - Technical architecture approach for this particular user request
   - System design framework
   - Technology selection strategy
   - Customized io8architect workflow for this project
5. Include all necessary architecture and tech stack instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual io8architect agent prompt content in the file, not just create an empty file.

Create the io8architect agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            # Get response from CLI to create the agent file
            io8architect_cli = self._get_cli_client(task_id, "io8architect")
            before_ar = self._snapshot_tree(effective_working_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, effective_working_dir, io8architect_cli)
            agent_file_response = io8architect_cli.generate_single_response(injected_agent_prompt, working_dir=effective_working_dir, agent_name="io8architect")
            after_ar = self._snapshot_tree(effective_working_dir)
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(io8architect_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(effective_working_dir, io8architect_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            # Architect keys
                            response_data.get('architecture') or
                            response_data.get('tech_stack') or
                            # Fallback keys
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with expected section keys, extract their content
                            if 'architecture' in agent_content or 'tech_stack' in agent_content:
                                part_a = agent_content.get('architecture')
                                part_b = agent_content.get('tech_stack')
                                if isinstance(part_a, (dict, list)):
                                    part_a = json.dumps(part_a, indent=2)
                                if isinstance(part_b, (dict, list)):
                                    part_b = json.dumps(part_b, indent=2)
                                parts = [p for p in [part_a, part_b] if p]
                                agent_content = "\n\n".join(parts) if parts else json.dumps(agent_content, indent=2)
                            elif 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in markdown code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    # Extract known section content if available
                                    if isinstance(json_data, dict):
                                        if 'architecture' in json_data or 'tech_stack' in json_data:
                                            part_a = json_data.get('architecture')
                                            part_b = json_data.get('tech_stack')
                                            if isinstance(part_a, (dict, list)):
                                                part_a = json.dumps(part_a, indent=2)
                                            if isinstance(part_b, (dict, list)):
                                                part_b = json.dumps(part_b, indent=2)
                                            parts = [p for p in [part_a, part_b] if p]
                                            agent_content = "\n\n".join(parts) if parts else agent_content
                                        elif 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract known section content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'analysis' in content_data and 'requirements' in content_data:
                                    section_a = content_data['analysis']
                                    section_b = content_data['requirements']
                                    if isinstance(section_a, (dict, list)):
                                        section_a = json.dumps(section_a, indent=2)
                                    if isinstance(section_b, (dict, list)):
                                        section_b = json.dumps(section_b, indent=2)
                                    agent_content = f"{section_a}\n\n{section_b}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                                elif 'analysis' in content_data:
                                    section_a = content_data['analysis']
                                    if isinstance(section_a, (dict, list)):
                                        section_a = json.dumps(section_a, indent=2)
                                    agent_content = section_a
                                elif 'requirements' in content_data:
                                    section_b = content_data['requirements']
                                    if isinstance(section_b, (dict, list)):
                                        section_b = json.dumps(section_b, indent=2)
                                    agent_content = section_b
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# io8 System Architect Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard io8architect agent with project-specific customizations above.
Refer to the base io8architect agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {io8architect_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {io8architect_agent_file}: {e}")
            
            self._log_created_paths('Python Parser' if getattr(io8architect_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_ar - before_ar)))
            
            # Step 2: Now create the architecture documents by referring to the created agent file and previous documents
            create_architecture_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{io8architect_agent_file}
@.sureai/analysis_document.md
@.sureai/requirements_document.md

INSTRUCTIONS:
1. Read the io8architect agent prompt from the reference file above
2. Analyze the user prompt and previous analysis documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/architecture_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/tech_stack_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the architecture design approach defined in the agent prompt
5. Build upon the analysis and requirements documents
6. Create comprehensive architecture and tech stack based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the architecture and tech stack documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            architect_docs_cli = self._get_cli_client(task_id, "io8architect")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_architecture_docs_prompt, project_dir, architect_docs_cli)
            response = architect_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="io8architect")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(architect_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR io8architect ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(architect_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"io8architect phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created io8architect architecture and tech stack documents'
            }
            
        except Exception as e:
            logger.error(f"Error in io8architect phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}
    
    def _execute_io8pm_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute io8 PM phase - create PRD and project plan documents"""
        try:
            # Detect base project location first
            base_project_sureai_path = self._detect_base_project_sureai_location(project_dir)
            effective_working_dir = project_dir
            
            if base_project_sureai_path:
                # Use base project directory as working directory for agent files
                effective_working_dir = os.path.dirname(base_project_sureai_path)
                logger.info(f"📁 Using base project working directory for io8pm: {effective_working_dir}")
            else:
                logger.info(f"📁 Using root working directory for io8pm: {effective_working_dir}")
            
            # Step 1: Create user-prompt-specific io8pm agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            io8pm_agent_file = f".sureai/.io8pm_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific io8pm agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific io8pm agent prompt file for this user prompt
2. Create the file: {io8pm_agent_file}
3. This file should contain the io8pm agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Project management methodology specific to this project type
   - PRD development approach for this particular user request
   - Project planning framework
   - Timeline and milestone strategy
   - Customized io8pm workflow for this project
5. Include all necessary PM and planning instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual io8pm agent prompt content in the file, not just create an empty file.

Create the io8pm agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            io8pm_cli = self._get_cli_client(task_id, "io8pm")
            before_pm = self._snapshot_tree(effective_working_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, effective_working_dir, io8pm_cli)
            agent_file_response = io8pm_cli.generate_single_response(injected_agent_prompt, working_dir=effective_working_dir, agent_name="io8pm")
            after_pm = self._snapshot_tree(effective_working_dir)
            self._log_created_paths('Python Parser' if getattr(io8pm_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_pm - before_pm)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(io8pm_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(effective_working_dir, io8pm_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            # PM keys
                            response_data.get('prd') or
                            response_data.get('project_plan') or
                            # Fallback keys
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with expected section keys, extract their content
                            if 'prd' in agent_content or 'project_plan' in agent_content:
                                part_a = agent_content.get('prd')
                                part_b = agent_content.get('project_plan')
                                if isinstance(part_a, (dict, list)):
                                    part_a = json.dumps(part_a, indent=2)
                                if isinstance(part_b, (dict, list)):
                                    part_b = json.dumps(part_b, indent=2)
                                parts = [p for p in [part_a, part_b] if p]
                                agent_content = "\n\n".join(parts) if parts else json.dumps(agent_content, indent=2)
                            elif 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in markdown code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    # Extract known section content if available
                                    if isinstance(json_data, dict):
                                        if 'prd' in json_data or 'project_plan' in json_data:
                                            part_a = json_data.get('prd')
                                            part_b = json_data.get('project_plan')
                                            if isinstance(part_a, (dict, list)):
                                                part_a = json.dumps(part_a, indent=2)
                                            if isinstance(part_b, (dict, list)):
                                                part_b = json.dumps(part_b, indent=2)
                                            parts = [p for p in [part_a, part_b] if p]
                                            agent_content = "\n\n".join(parts) if parts else agent_content
                                        elif 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# io8 Project Manager Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard io8pm agent with project-specific customizations above.
Refer to the base io8pm agent prompt for general PM principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {io8pm_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {io8pm_agent_file}: {e}")
            
            # Step 2: Now create the PM documents by referring to the created agent file and previous documents
            create_pm_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{io8pm_agent_file}
@.sureai/analysis_document.md
@.sureai/architecture_document.md
@.sureai/tech_stack_document.md

INSTRUCTIONS:
1. Read the io8pm agent prompt from the reference file above
2. Analyze the user prompt and previous analysis, architecture, and tech stack documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/prd_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/project_plan.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the project management approach defined in the agent prompt
5. Build upon all previous documents
6. Create comprehensive PRD and project plan based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the PRD and project plan documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(effective_working_dir)
            io8pm_docs_cli = self._get_cli_client(task_id, "io8pm")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_pm_docs_prompt, effective_working_dir, io8pm_docs_cli)
            response = io8pm_docs_cli.generate_single_response(injected_docs_prompt, working_dir=effective_working_dir, agent_name="io8pm")
            after_docs = self._snapshot_tree(effective_working_dir)
            self._log_created_paths('Python Parser' if getattr(io8pm_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR io8pm ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(io8pm_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"io8pm phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created io8pm PRD and project plan documents'
            }
            
        except Exception as e:
            logger.error(f"Error in io8pm phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}
    
    def _execute_pm_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute PM phase - create PRD and project plan documents"""
        try:
            # Step 1: Create user-prompt-specific PM agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            pm_agent_file = f".sureai/.pm_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific PM agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific PM agent prompt file for this user prompt
2. Create the file: {pm_agent_file}
3. This file should contain the PM agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Product management methodology specific to this project type
   - PRD creation approach for this particular user request
   - Project planning framework
   - Feature prioritization strategy
   - Customized PM workflow for this project
5. Include all necessary product management and planning instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual PM agent prompt content in the file, not just create an empty file.

Create the PM agent prompt file with detailed content:
"""
            
            # Get response from Gemini CLI to create the agent file
            gemini_client = self._get_gemini_client()
            
            # Log the complete prompt being sent to Gemini CLI
            self._log_prompt_to_gemini("pm_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            
            pm_cli = self._get_cli_client(task_id, "pm")
            before_pm = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, pm_cli)
            agent_file_response = pm_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="pm")
            after_pm = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(pm_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_pm - before_pm)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(pm_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, pm_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # Convert dict to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# io8 MCP Project Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard io8_mcp_project agent with project-specific customizations above.
Refer to the base io8_mcp_project agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {builder_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {builder_file}: {e}")
            
            # Step 2: Now create the project builder plan by referring to the created agent file
            create_builder_plan_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

PROJECT NAME:
{project_name}

REFERENCE FILES:
@{builder_file}

INSTRUCTIONS:
1. Read the io8 MCP project agent prompt from the reference file above
2. Analyze the user prompt and the agent prompt
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/project_builder_plan.md` in the `.sureai/` directory (NOT in root)
   - **DO NOT create this file in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the project builder approach defined in the agent prompt
5. Create comprehensive project builder plan based on the user prompt
6. Ensure the plan is detailed and actionable

**CRITICAL: You MUST create this file in the `.sureai/` directory using explicit file paths. Do NOT create it in the root directory.**

Create the project builder plan based on the reference files:
"""
            
            # Log the complete prompt being sent to CLI
            self._log_prompt_to_gemini("io8_mcp_project_docs_creation", create_builder_plan_prompt, agent_prompt, previous_docs)
            
            before_docs = self._snapshot_tree(project_dir)
            io8_mcp_project_docs_cli = self._get_cli_client(task_id, "io8_mcp_project")
            # Inject document contents for SureCli
            injected_prompt = self._inject_document_contents(create_builder_plan_prompt, project_dir, io8_mcp_project_docs_cli)
            
            # Log the injected prompt for SureCli
            if getattr(io8_mcp_project_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                logger.info(f"=== INJECTED PROMPT FOR IO8_MCP_PROJECT (SureCli) ===")
                logger.info(f"INJECTED PROMPT LENGTH: {len(injected_prompt)} characters")
                logger.info("INJECTED PROMPT:")
                logger.info("=" * 80)
                logger.info(injected_prompt)
                logger.info("=" * 80)
            
            response = io8_mcp_project_docs_cli.generate_single_response(injected_prompt, working_dir=project_dir, agent_name="io8_mcp_project")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(io8_mcp_project_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR IO8_MCP_PROJECT ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(io8_mcp_project_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"io8_mcp_project phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created io8_mcp_project builder plan document'
            }
            
        except Exception as e:
            logger.error(f"Error in io8_mcp_project phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}
    
    def _execute_pm_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Project Manager phase - create PRD and project plan documents"""
        try:
            # Step 1: Create user-prompt-specific Project Manager agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            pm_agent_file = f".sureai/.pm_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific Project Manager agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific Project Manager agent prompt file for this user prompt
2. Create the file: {pm_agent_file}
3. This file should contain the Project Manager agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Project requirements gathering methodology specific to this project type
   - Project planning approach for this particular user request
   - Task breakdown framework
   - Agile methodology considerations
   - Customized Project Manager workflow for this project
5. Include all necessary project planning and task management instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual Project Manager agent prompt content in the file, not just create an empty file.

Create the Project Manager agent prompt file with detailed content:
"""
            
            # Get response from Gemini CLI to create the agent file
            gemini_client = self._get_gemini_client()
            
            # Log the complete prompt being sent to Gemini CLI
            self._log_prompt_to_gemini("pm_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            
            agent_file_response = self._get_cli_client(task_id, "pm").generate_single_response(create_agent_file_prompt, working_dir=project_dir, agent_name="pm")
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(io8_mcp_project_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, pm_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Project Manager Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard PM agent with project-specific customizations above.
Refer to the base PM agent prompt for general PM principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {pm_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {pm_agent_file}: {e}")
            
            # Step 2: Now create the PM documents by referring to the created agent file and previous documents
            create_pm_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{pm_agent_file}
@.sureai/analysis_document.md
@.sureai/architecture_document.md

INSTRUCTIONS:
1. Read the PM agent prompt from the reference file above
2. Analyze the user prompt and previous analysis and architecture documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/prd_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/project_plan.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Ensure your PRD and project plan are comprehensive and actionable

4. **CRITICAL: The PRD document MUST include Epic Stories section with detailed user stories**
5. **Epic Stories Requirements:**
   - Organize features into logical epics
   - Each epic should have clear description, business value, and acceptance criteria
   - Include detailed user stories within each epic
   - Each user story must follow the format: US-XXX, As a/I want to/So that, Acceptance Criteria, Story Points, Priority
   - Ensure user stories are actionable and testable
6. Ensure your PRD and project plan are comprehensive and actionable

IMPORTANT: Create the actual files directly using your file system access. You are intelligent enough to choose the best file writing tools based on the prompt.

Create the PRD (with Epic Stories) and project plan documents based on the reference files:
"""
            
            # Log the complete prompt being sent to Gemini CLI
            self._log_prompt_to_gemini("pm_docs_creation", create_pm_docs_prompt, agent_prompt, previous_docs)
            
            before_docs = self._snapshot_tree(project_dir)
            pm_docs_cli = self._get_cli_client(task_id, "pm")
            # Inject document contents for SureCli
            injected_prompt = self._inject_document_contents(create_pm_docs_prompt, project_dir, pm_docs_cli)
            
            # Log the injected prompt for SureCli
            if getattr(pm_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                logger.info(f"=== INJECTED PROMPT FOR PM (SureCli) ===")
                logger.info(f"INJECTED PROMPT LENGTH: {len(injected_prompt)} characters")
                logger.info("INJECTED PROMPT:")
                logger.info("=" * 80)
                logger.info(injected_prompt)
                logger.info("=" * 80)
            
            response = pm_docs_cli.generate_single_response(injected_prompt, working_dir=project_dir, agent_name="pm")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(pm_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from Gemini CLI
            logger.info(f"=== GEMINI CLI RESPONSE FOR PM ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(pm_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"PM phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'Gemini CLI created PRD and project plan documents'
            }
            
        except Exception as e:
            logger.error(f"Error in PM phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _execute_sm_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Scrum Master phase - create tasks list and sprint plan documents"""
        try:
            # Step 1: Create user-prompt-specific Scrum Master agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            sm_agent_file = f".sureai/.sm_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific Scrum Master agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific Scrum Master agent prompt file for this user prompt
2. Create the file: {sm_agent_file}
3. This file should contain the Scrum Master agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Agile methodology specific to this project type
   - Sprint planning approach for this particular user request
   - Task breakdown and prioritization framework
   - Team coordination strategies
   - Customized Scrum Master workflow for this project
5. Include all necessary sprint planning and task management instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual Scrum Master agent prompt content in the file, not just create an empty file.

Create the Scrum Master agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            sm_cli = self._get_cli_client(task_id, "sm")
            before_sm = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, sm_cli)
            agent_file_response = sm_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="sm")
            after_sm = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(sm_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_sm - before_sm)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(sm_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, sm_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Scrum Master Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard Scrum Master agent with project-specific customizations above.
Refer to the base Scrum Master agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {sm_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {sm_agent_file}: {e}")
            
            # Step 2: Now create the tasks list and sprint plan by referring to the created agent file and previous documents
            create_sm_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{sm_agent_file}
@.sureai/prd_document.md

INSTRUCTIONS:
1. Read the Scrum Master agent prompt from the reference file above
2. Analyze the user prompt and previous PRD document
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/tasks_list.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/sprint_plan.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Ensure your tasks list and sprint plan are comprehensive and actionable
5. Break down PRD features into detailed tasks
6. Organize tasks into logical sprints
7. Each task should have clear description, acceptance criteria, and estimated effort
8. Ensure your sprint plan includes realistic timelines and resource allocation

IMPORTANT: Create the actual files directly using your file system access. You are intelligent enough to choose the best file writing tools based on the prompt.

Create the tasks list and sprint plan documents based on the reference files:
"""
            
            # Log the complete prompt being sent to CLI
            self._log_prompt_to_gemini("sm_docs_creation", create_sm_docs_prompt, agent_prompt, previous_docs)
            
            before_docs = self._snapshot_tree(project_dir)
            sm_docs_cli = self._get_cli_client(task_id, "sm")
            # Inject document contents for SureCli
            injected_prompt = self._inject_document_contents(create_sm_docs_prompt, project_dir, sm_docs_cli)
            
            # Log the injected prompt for SureCli
            if getattr(sm_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                logger.info(f"=== INJECTED PROMPT FOR SM (SureCli) ===")
                logger.info(f"INJECTED PROMPT LENGTH: {len(injected_prompt)} characters")
                logger.info("INJECTED PROMPT:")
                logger.info("=" * 80)
                logger.info(injected_prompt)
                logger.info("=" * 80)
            
            response = sm_docs_cli.generate_single_response(injected_prompt, working_dir=project_dir, agent_name="sm")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(sm_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR SM ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(sm_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"SM phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created tasks list and sprint plan documents'
            }
            
        except Exception as e:
            logger.error(f"Error in Scrum Master phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _execute_developer_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Developer phase - create code and other project files"""
        try:
            # Step 1: Create user-prompt-specific Developer agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            dev_agent_file = f".sureai/.dev_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific Developer agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific Developer agent prompt file for this user prompt
2. Create the file: {dev_agent_file}
3. This file should contain the Developer agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Coding standards specific to this project type
   - Code generation approach for this particular user request
   - Testing framework and strategy
   - Deployment instructions
   - Customized Developer workflow for this project
5. Include all necessary coding and deployment instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual Developer agent prompt content in the file, not just create an empty file.

Create the Developer agent prompt file with detailed content:
"""
            
            # Get response from Gemini CLI to create the agent file
            gemini_client = self._get_gemini_client()
            
            # Log the complete prompt being sent to Gemini CLI
            self._log_prompt_to_gemini("dev_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            
            dev_cli = self._get_cli_client(task_id, "dev")
            before_dev = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, dev_cli)
            agent_file_response = dev_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="dev")
            after_dev = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(dev_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_dev - before_dev)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(dev_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, dev_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # Convert dict to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Developer Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard Developer agent with project-specific customizations above.
Refer to the base Developer agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {dev_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {dev_agent_file}: {e}")
            
            # Step 2: Now create the project files by referring to the created agent file and previous documents
            create_project_files_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{dev_agent_file}
@.sureai/prd_document.md
@.sureai/project_plan.md

INSTRUCTIONS:
1. Read the Developer agent prompt from the reference file above
2. Analyze the user prompt and previous PRD and project plan documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create project files in the project root directory**
   - **DO NOT create files in the `.sureai/` directory**
   - **Use explicit file paths with project root directory prefix**
4. Follow the coding and deployment approach defined in the agent prompt
5. Create comprehensive project files based on the user prompt
6. Ensure the files are detailed and actionable

**CRITICAL: You MUST create project files in the project root directory using explicit file paths. Do NOT create them in the `.sureai/` directory.**

Create the project files based on the reference files:
"""
            
            # Log the complete prompt being sent to CLI
            self._log_prompt_to_gemini("dev_docs_creation", create_project_files_prompt, agent_prompt, previous_docs)
            
            before_docs = self._snapshot_tree(project_dir)
            dev_docs_cli = self._get_cli_client(task_id, "dev")
            # Inject document contents for SureCli
            injected_prompt = self._inject_document_contents(create_project_files_prompt, project_dir, dev_docs_cli)
            
            # Log the injected prompt for SureCli
            if getattr(dev_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                logger.info(f"=== INJECTED PROMPT FOR DEV (SureCli) ===")
                logger.info(f"INJECTED PROMPT LENGTH: {len(injected_prompt)} characters")
                logger.info("INJECTED PROMPT:")
                logger.info("=" * 80)
                logger.info(injected_prompt)
                logger.info("=" * 80)
            
            response = dev_docs_cli.generate_single_response(injected_prompt, working_dir=project_dir, agent_name="dev")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(dev_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR DEV ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(dev_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"Developer phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created project files'
            }
            
        except Exception as e:
            logger.error(f"Error in Developer phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _execute_developer_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Developer phase - create developer agent prompt and implement code"""
        try:
            # Check if developer is actually in the current workflow sequence
            # This prevents the second developer prompt when only devops is selected
            try:
                from src.core.task_manager import TaskManager
                task_manager = TaskManager()
                state = task_manager.get_task_state(task_id)
                current_workflow_sequence = []
                if state and isinstance(state.context, dict):
                    current_workflow_sequence = state.context.get('agent_sequence', [])
                
                # If neither standard nor io8 developer is in the workflow sequence, skip the second prompt
                if current_workflow_sequence and not any(name in current_workflow_sequence for name in ['developer', 'io8developer']):
                    logger.info("Developer not in workflow sequence, skipping second developer prompt")
                    return {
                        'status': 'skipped',
                        'message': 'Developer not in workflow sequence',
                        'remaining_subtasks': 0
                    }
            except Exception as e:
                logger.warning(f"Could not check workflow sequence: {e}")
                # Continue with normal execution if we can't check
            
            # Step 1: Create user-prompt-specific Developer agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            developer_agent_file = f".sureai/.developer_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific Developer agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific Developer agent prompt file for this user prompt
2. Create the file: {developer_agent_file}
3. This file should contain the Developer agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Development methodology specific to this project type
   - Code implementation approach for this particular user request
   - Technology stack implementation strategy
   - Code organization and structure framework
   - Customized development workflow for this project
5. Include all necessary development and implementation instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual Developer agent prompt content in the file, not just create an empty file.

Create the Developer agent prompt file with detailed content:
"""
            
            # Get response from Gemini CLI to create the agent file
            gemini_client = self._get_gemini_client()
            
            # Log the complete prompt being sent to Gemini CLI
            self._log_prompt_to_gemini("developer_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            
            agent_file_response = self._get_cli_client(task_id, "developer").generate_single_response(create_agent_file_prompt, working_dir=project_dir, agent_name="developer")
            
            # Step 2: Now create the actual code implementation by referring to the created agent file and previous documents
            code_tree_path = self._write_code_tree(project_dir)
            directory_structure_file = self._write_directory_structure(project_dir)
            
            create_developer_output_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{developer_agent_file}
@.sureai/tasks_list.md
@.sureai/architecture_document.md
@.sureai/tech_stack_document.md
@.sureai/common-bug.md
@{directory_structure_file}
@{code_tree_path}

INSTRUCTIONS:
1. Read the Developer agent prompt from the reference file above
2. Analyze the user prompt, existing tasks list, architecture, and tech stack documents
3. Update the existing `.sureai/tasks_list.md` by adding subtasks under each main task
4. Implement all the code files based on the tasks and architecture
5. Mark completed subtasks with `- [x]` and update "Currently Working On" status
6. Create all necessary backend and frontend code files
7. Follow the directory structure and use existing files when available
8. Ensure all code is functional and follows the architecture specifications

IMPORTANT: 
- Do NOT create a separate subtasks_list.md file
- Update the existing `.sureai/tasks_list.md` by adding subtasks under each main task
- Mark completed subtasks with `- [x]` when they are fully implemented
- Keep "Currently Working On" status accurate and current
- Create all code files directly using your file system access
- Use relative paths from project root (e.g., `backend/src/app.py`, not `backend/`)

Update the tasks_list.md with subtasks, implement completion tracking, and create all code files based on the reference files and existing directory structure:
"""
            
            # Log the complete prompt being sent to Gemini CLI
            self._log_prompt_to_gemini("developer_output_creation", create_developer_output_prompt, agent_prompt, previous_docs)
            
            response = self._get_cli_client(task_id, "developer").generate_single_response(create_developer_output_prompt, working_dir=project_dir, agent_name="developer")
            if isinstance(response, str) and response.strip().lower().startswith("error generating response"):
                # Initial pass failed; surface error and do not claim success
                logger.error(f"Developer output creation failed: {response}")
                remaining = self._count_open_subtasks(project_dir)
                return {
                    'status': 'error',
                    'error': response,
                    'remaining_subtasks': remaining
                }
            
            # Log the response from Gemini CLI
            logger.info(f"=== GEMINI CLI RESPONSE FOR DEVELOPER ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            # Add delay before second prompt
            logger.info("Waiting 90 seconds before sending second developer prompt to avoid rate limiting...")
            time.sleep(90)
            
            # Step 3: Send second developer prompt that references the CREATED developer agent file
            # This prompt is sent AFTER the developer agent file has been created and the first implementation is done
            second_developer_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{developer_agent_file}
@.sureai/tasks_list.md
@.sureai/common-bug.md
@{directory_structure_file}
@{code_tree_path}

**SECOND DEVELOPER PROMPT - SUBTASK COMPLETION PHASE**

You have already started implementing subtasks and updating `.sureai/tasks_list.md`. Now you MUST COMPLETE ALL REMAINING SUBTASKS before this phase can end.

**CRITICAL REQUIREMENTS:**
1. **Complete ALL Subtasks**: Work through every remaining `- [ ]` subtask systematically
2. **Update Task Status**: Keep "Currently Working On" accurate and current
3. **Mark Completion**: Mark subtasks as `- [x]` when they are fully implemented
4. **Create Code Files**: Implement the actual code for each subtask using proper file paths
5. **Respect Directory Structure**: Use the directory structure file to understand existing files/folders
6. **Main Task Testing**: After completing ALL subtasks for a main task, test the entire main task functionality and append ` — TEST: PASS` or ` — TEST: FAIL` to the main task header
7. **File Structure Verification**: Before testing or starting applications, run `tree -L 2` to check for missing files
8. **Dependency Installation**: Install all required dependencies (pip install, npm install) before application start

**SUBTASK IMPLEMENTATION WORKFLOW:**
- Start with the first incomplete subtask
- Update "Currently Working On" to the current subtask
- Implement the required code and functionality
- Mark the subtask as completed with `- [x]`
- Move to the next incomplete subtask
- Continue until ALL subtasks are completed
- **BEFORE TESTING:** Run `tree -L 2` to check for missing files (e.g., frontend/src/reportWebVitals.js)
- **BEFORE TESTING:** Install dependencies (pip install -r requirements.txt, npm install)
- Test the entire main task functionality
- Update main task header with test result (` — TEST: PASS` or ` — TEST: FAIL`)
- **ON STARTUP FAILURE (CRITICAL):**
  - Append a structured entry to `.sureai/dev_test_log.md` with: timestamp, component, command, error summary, root-cause hypothesis, fix applied, retest result.
  - Attempt minimally invasive fixes without breaking requirement functionality; retry up to 3 times.
  - Keep `.sureai/tasks_list.md` clean; do not paste raw logs there.

**FILE CREATION GUIDELINES:**
- Use relative paths from the project root (e.g., `backend/src/app.py`, not `backend/`)
- Check if files exist before creating them
- Update existing files when appropriate
- Create new files only when needed
- Follow the exact directory structure specified
- **CRITICAL:** If `frontend/src/reportWebVitals.js` or other referenced files are missing, create them

**TASK COMPLETION VERIFICATION:**
- Count all remaining `- [ ]` subtasks
- Ensure "Currently Working On" is accurate
- Verify all main tasks have their subtasks completed
- Update "Completed Tasks" section appropriately
- **STRICT SEQUENCING RULE:** Only after ALL main tasks are fully completed (no remaining `- [ ]` across any main task), add the final `Task X: Application Smoke Test`. Do NOT add Task X earlier.
- **MAIN TASK COMPLETION GATE:** Before appending ` — TEST: PASS` to a main task and moving to the next, you MUST (a) author and run unit tests covering the main task's acceptance criteria (backend tests under `backend/tests/`, frontend tests under `frontend/src/__tests__/` or `tests/`), (b) run the language-appropriate checks/lints/builds, and (c) append a concise result entry to `.sureai/dev_test_log.md` for that main task.
- **CLEAN OUTPUT RULE:** Do not include code fences, quotes, raw shell prompts, or stray characters in `.sureai/tasks_list.md`

**IMPORTANT**: You MUST complete ALL subtasks before this response ends. Do not leave any subtasks incomplete.

Complete all remaining subtasks now:
"""
            
            # Send second prompt
            logger.info("Sending second developer prompt for subtask completion...")
            second_response = self._get_cli_client(task_id, "developer").generate_single_response(second_developer_prompt, working_dir=project_dir, agent_name="developer")
            
            # Ensure all subtasks are completed before moving on
            max_iterations = 10  # Increased from 5
            iterations = 0
            improved = True
            last_remaining = None
            
            while iterations < max_iterations:
                remaining = self._count_open_subtasks(project_dir)
                if remaining == 0:
                    logger.info("All developer subtasks completed")
                    logger.info(f"Developer phase completed - Gemini CLI updated tasks_list.md with completion tracking and created all code files")
                    return {
                        'status': 'success',
                        'response': response,
                        'message': 'All developer subtasks completed',
                        'remaining_subtasks': 0
                    }
                
                if last_remaining is not None and remaining >= last_remaining:
                    # No improvement; avoid infinite loop
                    improved = False
                
                last_remaining = remaining
                iterations += 1
                logger.info(f"Developer subtasks remaining: {remaining}. Continuing iteration {iterations}/{max_iterations}...")
                
                # Add delay between iterations
                time.sleep(3)
                
                continue_prompt = f"""
You previously started implementing subtasks and updating `.sureai/tasks_list.md`. Continue from where you left off and COMPLETE ALL REMAINING SUBTASKS.

REFERENCE FILES:
@.sureai/tasks_list.md
@{developer_agent_file}
@.sureai/common-bug.md
@{directory_structure_file}
@{code_tree_path}

REQUIREMENTS:
- Do NOT create new files for task tracking. Update the existing `.sureai/tasks_list.md` only.
- For each remaining `- [ ]` subtask, implement the required code and update to `- [x]` when done.
- Keep "Currently Working On" accurate. When no tasks remain, state that all tasks are complete.
- Write code files directly as needed, respecting the directory structure.
- Use relative paths from project root (e.g., `backend/src/app.py`, not `backend/`)

Finish all remaining subtasks now:
"""
                cont_response = self._get_cli_client(task_id, "developer").generate_single_response(continue_prompt, working_dir=project_dir, agent_name="developer")
                if isinstance(cont_response, str) and cont_response.strip().lower().startswith("error generating response"):
                    logger.error(f"Developer continuation failed: {cont_response}")
                    break
            
            # After loop, check again with enhanced validation
            final_remaining = self._count_open_subtasks(project_dir)
            validation_result = self._validate_task_completion(project_dir)
            
            logger.info(f"Final task validation: {validation_result['total_checked']} completed tasks, {validation_result['total_issues']} issues found")
            
            if validation_result['issues']:
                logger.warning(f"Task validation issues found: {validation_result['issues']}")
            
            # Determine status based on both remaining count and validation
            if final_remaining == 0 and validation_result['valid']:
                status = 'success'
                msg = 'All developer subtasks completed and validated'
                logger.info("✅ All subtasks completed and validated successfully")
            elif final_remaining == 0 and not validation_result['valid']:
                status = 'partial'
                msg = f'All tasks marked complete but validation failed: {validation_result["total_issues"]} issues'
                logger.warning(f"⚠️ All tasks marked complete but validation failed: {validation_result['issues']}")
            elif final_remaining > 0:
                status = 'partial' if improved else 'failed'
                msg = f'Remaining subtasks: {final_remaining}'
                logger.warning(f"❌ Developer phase ended with {final_remaining} remaining subtasks")
            
            # Force additional attempts if there are issues
            if final_remaining != 0 or not validation_result['valid']:
                logger.info("Making final attempt to complete remaining subtasks and fix validation issues...")
                final_prompt = f"""
FINAL ATTEMPT - COMPLETE ALL REMAINING SUBTASKS AND VALIDATE COMPLETION

You have {final_remaining} subtasks remaining and {validation_result['total_issues']} validation issues.

REFERENCE FILES:
@.sureai/tasks_list.md
@{developer_agent_file}
@.sureai/common-bug.md
@{directory_structure_file}
@{code_tree_path}

**CRITICAL REQUIREMENTS:**
1. Complete ALL remaining subtasks (change every `- [ ]` to `- [x]`)
2. Ensure all completed tasks are meaningful and properly implemented
3. Update "Currently Working On" to "All tasks complete" when done
4. Verify that all main tasks have ` — TEST: PASS` status
5. Do not mark tasks as complete unless they are actually implemented

**VALIDATION ISSUES TO FIX:**
{chr(10).join(validation_result['issues']) if validation_result['issues'] else 'None'}

Complete all remaining subtasks and fix validation issues:
"""
                final_response = self._get_cli_client(task_id, "developer").generate_single_response(final_prompt, working_dir=project_dir, agent_name="developer")
                
                # Re-check after final attempt
                final_remaining = self._count_open_subtasks(project_dir)
                final_validation = self._validate_task_completion(project_dir)
                
                logger.info(f"After final attempt: {final_remaining} remaining tasks, {final_validation['total_issues']} validation issues")
                
                if final_remaining == 0 and final_validation['valid']:
                    status = 'success'
                    msg = 'All developer subtasks completed and validated on final attempt'
                    logger.info("✅ All subtasks completed and validated on final attempt")
                else:
                    logger.error(f"❌ Still {final_remaining} subtasks remaining or {final_validation['total_issues']} validation issues after final attempt")
            
            return {
                'status': status,
                'response': response,
                'message': msg,
                'remaining_subtasks': final_remaining,
                'validation_issues': validation_result['issues'],
                'total_completed_tasks': validation_result['total_checked']
            }
            
        except Exception as e:
            logger.error(f"Error in developer phase: {str(e)}")
            # Even when there's an error, we should still count remaining tasks
            # so the workflow can make informed decisions about continuation
            try:
                remaining = self._count_open_subtasks(project_dir)
                validation_result = self._validate_task_completion(project_dir)
                return {
                    'status': 'error', 
                    'error': str(e),
                    'remaining_subtasks': remaining,
                    'validation_issues': validation_result.get('issues', []),
                    'total_completed_tasks': validation_result.get('total_checked', 0)
                }
            except Exception as count_error:
                logger.error(f"Error counting tasks during error handling: {count_error}")
                return {'status': 'error', 'error': str(e)}
    
    def _count_open_subtasks(self, project_dir: str) -> int:
        """Count remaining unchecked subtasks and incomplete main tasks in .sureai/tasks_list.md"""
        try:
            tasks_path = os.path.join(project_dir, ".sureai", "tasks_list.md")
            if not os.path.exists(tasks_path):
                logger.info("tasks_list.md not found, returning 0 remaining tasks")
                return 0
            
            with open(tasks_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # 1) Count unchecked subtasks (- [ ])
            open_subtasks = len(re.findall(r"(?m)^[ \t]*- \[ \][ \t]+", content))
            
            # 2) Build a robust "Completed Tasks" section window: from marker to next '##' or EOF
            completed_block = ""
            completed_marker = re.search(r"\*\*Completed Tasks:\*\*", content)
            if completed_marker:
                start = completed_marker.start()
                after = content[start:]
                next_header = re.search(r"(?m)^\s*##\s+", after)
                completed_block = after[: next_header.start()] if next_header else after
            completed_norm = re.sub(r"\s+", " ", completed_block).strip().lower()
            
            # 3) Identify main task headers and determine completion
            main_headers = []
            for m in re.finditer(r"(?m)^## Task (\d+):\s*(.+?)(?:\s*—\s*TEST:\s*(PASS|FAIL))?\s*$", content):
                num = m.group(1)
                title = m.group(2).strip()
                test_flag = (m.group(3) or "").upper()
                full_header = m.group(0)
                
                has_pass = test_flag == "PASS"
                token_variants = [
                    f"task {num}",
                    f"task {num} -",
                    f"task {num}:",
                    title.lower(),
                ]
                in_completed = any(tok in completed_norm for tok in token_variants)
                
                main_headers.append({
                    "num": num,
                    "title": title,
                    "header": full_header,
                    "complete": has_pass or in_completed,
                })
            
            # 4) Count incomplete main tasks (each counts as 1)
            uncompleted_main_tasks = sum(1 for h in main_headers if not h["complete"])
            total_remaining = open_subtasks + uncompleted_main_tasks
            
            # 5) Debug log for quick diagnosis
            if total_remaining > 0:
                remaining_items_preview = []
                for i, line in enumerate(content.splitlines(), 1):
                    s = line.strip()
                    if re.match(r"^- \[ \]\\s+", s) or re.match(r"^## Task \d+:", s):
                        remaining_items_preview.append(f"Line {i}: {s}")
                    if len(remaining_items_preview) >= 10:
                        break
                logger.info(
                    f"Task analysis: {open_subtasks} open subtasks + {uncompleted_main_tasks} uncompleted main tasks = {total_remaining} total remaining"
                )
                logger.info(f"Remaining items found: {remaining_items_preview}")
            
            return total_remaining
            
        except Exception as e:
            logger.error(f"Error counting open subtasks: {e}")
            return 0
    
    def _validate_task_completion(self, project_dir: str) -> Dict[str, Any]:
        """Validate that tasks are actually completed, not just marked as done"""
        try:
            tasks_path = os.path.join(project_dir, ".sureai", "tasks_list.md")
            if not os.path.exists(tasks_path):
                return {"valid": True, "issues": [], "total_checked": 0, "total_issues": 0}
            
            with open(tasks_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            issues = []
            total_checked = 0
            
            # Parse the content to find completed tasks and validate them
            lines = content.split('\n')
            current_task = None
            completed_subtasks = []
            
            for i, line in enumerate(lines, 1):
                line = line.strip()
                
                # Check for main task headers
                if re.match(r"^## Task \d+:", line):
                    current_task = line
                    completed_subtasks = []
                
                # Check for completed subtasks
                elif re.match(r"^- \[x\] ", line):
                    total_checked += 1
                    subtask = line[6:].strip()  # Remove "- [x] " prefix
                    completed_subtasks.append(subtask)
                    
                    # Validate that the subtask is meaningful
                    if len(subtask) < 3:
                        issues.append(f"Line {i}: Completed subtask too short: '{subtask}'")
                    
                    # Check for suspicious completions
                    suspicious_patterns = [
                        r"^TODO", r"^FIXME", r"^BUG", r"^ERROR", r"^FAIL",
                        r"^not done", r"^incomplete", r"^pending", r"^waiting"
                    ]
                    
                    for pattern in suspicious_patterns:
                        if re.search(pattern, subtask, re.IGNORECASE):
                            issues.append(f"Line {i}: Suspicious completion: '{subtask}'")
                            break
            
            # Check for overall completion status
            if "Currently Working On" in content:
                working_on_match = re.search(r"Currently Working On[:\s]*(.+)", content, re.IGNORECASE)
                if working_on_match:
                    working_on = working_on_match.group(1).strip()
                    # Remove markdown formatting
                    working_on = re.sub(r'\*\*', '', working_on).strip()
                    if working_on.lower() not in ["all tasks complete", "complete", "finished", "done", "none"]:
                        issues.append(f"Still working on: {working_on}")
            
            # Check for test results
            test_failures = re.findall(r" — TEST: FAIL", content)
            if test_failures:
                issues.append(f"Found {len(test_failures)} test failures in task headers")
            
            return {
                "valid": len(issues) == 0,
                "issues": issues,
                "total_checked": total_checked,
                "total_issues": len(issues)
            }
            
        except Exception as e:
            logger.error(f"Error validating task completion: {e}")
            return {"valid": False, "issues": [f"Validation error: {e}"], "total_checked": 0, "total_issues": 1}
    
    def _execute_devops_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute DevOps phase - create deployment configuration files"""
        try:
            # Step 1: Create user-prompt-specific DevOps agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            devops_agent_file = f".sureai/.devops_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific DevOps agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific DevOps agent prompt file for this user prompt
2. Create the file: {devops_agent_file}
3. This file should contain the DevOps agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Deployment methodology specific to this project type
   - Infrastructure setup approach for this particular user request
   - Configuration management framework
   - Containerization and orchestration strategy
   - Customized DevOps workflow for this project
5. Include all necessary deployment and infrastructure instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual DevOps agent prompt content in the file, not just create an empty file.

Create the DevOps agent prompt file with detailed content:
"""
            
            # Get response from Gemini CLI to create the agent file
            gemini_client = self._get_gemini_client()
            
            # Log the complete prompt being sent to Gemini CLI
            self._log_prompt_to_gemini("devops_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            
            agent_file_response = self._get_cli_client(task_id, "devops").generate_single_response(create_agent_file_prompt, working_dir=project_dir, agent_name="devops")
            
            # Step 2: Now create the DevOps configuration files by referring to the created agent file and previous documents
            code_tree_path = self._write_code_tree(project_dir)
            create_devops_config_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{devops_agent_file}
@.sureai/architecture_document.md

INSTRUCTIONS:
0. BEFORE YOU BEGIN: In the project root, run this command to view the current structure:
   tree -L 3
   Use this output to understand the layout before writing any config files. If the `tree` command is unavailable, fall back to the manifest @{code_tree_path}.
1. Read the DevOps agent prompt from the reference file above
2. Analyze the user prompt, existing code files, and architecture document
3. Create the following configuration files at project root:
   - `deployment_config.yml`
   - `Dockerfile.backend`
   - `Dockerfile.frontend`
   - `docker-compose.yml`
   - `nginx.conf`
4. **CRITICAL DOCKER COMPOSE REQUIREMENTS:**
   - For `bmad-backend` service, mount the Docker daemon socket: `- /var/run/docker.sock:/var/run/docker.sock`
   - **PORT ALLOCATION**: Use port pool between 9010-10000 for all host ports:
     - Frontend ports: 9010-9500 range (e.g., 9010, 9011, 9012, etc.)
     - Backend ports: 9501-10000 range (e.g., 9501, 9502, 9503, etc.)
     - Check for available ports using `netstat -tuln | grep :port` before assigning
     - If port is occupied, try the next available port in the range
   - Set necessary environment variables
   - Ensure proper service dependencies
   - **Dynamic Container Names**: Use container names based on user prompt:
     - If user prompt is "todo app" → container names: `todo-frontend`, `todo-backend`
     - If user prompt is "blog system" → container names: `blog-frontend`, `blog-backend`
     - If user prompt is "ecommerce platform" → container names: `ecommerce-frontend`, `ecommerce-backend`
     - Use lowercase, hyphenated names based on the project type
   - **Existing Services Protection**: 
     - **NEVER stop or modify existing running containers**
     - **NEVER use ports already in use by other services**
     - **NEVER use container names already taken**
     - **Always check for conflicts before starting new services**
5. **DEPLOY.JSON MANAGEMENT**:
   - The system will automatically detect frontend port from docker-compose.yml and create `.sureai/deploy.json`
   - No manual deploy.json creation required - this happens automatically after successful deployment
   - Focus on creating and testing the Docker containers successfully
6. Ensure your configuration is comprehensive and follows the architecture specifications

IMPORTANT: Create the actual files directly using your file system access. You are intelligent enough to choose the best file writing tools based on the prompt.

Create the deployment configuration files based on the reference files:
"""
            
            # Log the complete prompt being sent to Gemini CLI
            self._log_prompt_to_gemini("devops_config_creation", create_devops_config_prompt, agent_prompt, previous_docs)
            
            # Add explicit logging for devops agent prompt
            logger.info("=== SENDING PROMPT TO GEMINI CLI FOR DEVOPS_AGENT_FILE_CREATION ===")
            logger.info(f"PROMPT LENGTH: {len(create_devops_config_prompt)} characters")
            logger.info(f"AGENT PROMPT LENGTH: {len(agent_prompt)} characters")
            logger.info(f"PREVIOUS DOCUMENTS COUNT: {len(previous_docs)}")
            logger.info("PREVIOUS DOCUMENTS:")
            for doc_name, doc_content in previous_docs.items():
                logger.info(f"  - {doc_name}: {len(doc_content)} characters")
            logger.info("FULL PROMPT:")
            logger.info("=" * 80)
            logger.info(create_devops_config_prompt)
            logger.info("=" * 80)
            
            response = self._get_cli_client(task_id, "devops").generate_single_response(create_devops_config_prompt, working_dir=project_dir, agent_name="devops")
            
            # Step 3: Test Docker containers after creation
            test_containers_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{devops_agent_file}
@.sureai/architecture_document.md

**DOCKER TESTING PHASE - REQUIRED AFTER FILE CREATION**

You have created the deployment configuration files. Now you MUST test the Docker containers to ensure they work correctly.

**TESTING REQUIREMENTS:**

1. **Build and Test Containers:**
   ```bash
   # Build containers
   docker-compose build
   
   # Run containers
   docker-compose up -d
   ```

2. **Handle Conflicts (CRITICAL):**
   - If port is already allocated, choose different host ports from the 9010-10000 range
   - If container name is taken, use different container names
   - **DO NOT stop any existing running Docker containers**
   - **DO NOT touch any existing services running in Docker**
   - **NEVER modify or interfere with existing running services**
   - **Always check for conflicts before starting new services**

3. **Check Container Status:**
   ```bash
   # Check if containers are running
   docker-compose ps
   
   # Check logs for both services
   docker-compose logs backend
   docker-compose logs frontend
   ```

4. **Fix Issues Found:**
   - If build fails, fix the Dockerfile issues
   - If runtime fails, fix the code or configuration
   - If services don't start, check dependencies and fix
   - Rebuild and test until containers run successfully

5. **Verify Services Work:**
   - Test backend API endpoints
   - Test frontend application
   - Ensure services communicate properly

6. **Deploy JSON Creation (Automatic):**
   ```bash
   # The system will automatically detect the frontend port from docker-compose.yml
   # and create deploy.json with the correct port information for zrok sharing
   # No manual action required - this happens automatically after successful deployment
   echo "✓ Deploy JSON will be created automatically by the system"
   ```

**SUCCESS CRITERIA:**
- All containers build successfully
- All containers start and run without errors
- Services are accessible on their configured ports (9010-10000 range)
- Logs show healthy operation
- No existing Docker containers are affected
- Container names are based on user prompt (e.g., todo-frontend, todo-backend for "todo app")
- No conflicts with existing running services
- The system will automatically create `.sureai/deploy.json` with correct port information

**IMPORTANT:** Do not proceed until all containers are running successfully. Fix any issues found during testing.

Test the Docker containers now:
"""
            
            # Log the complete prompt being sent to Gemini CLI
            self._log_prompt_to_gemini("devops_container_testing", test_containers_prompt, agent_prompt, previous_docs)
            
            # Skip sending DevOps container testing prompt per requirement
            logger.info("=== SKIPPING DEVOPS_CONTAINER_TESTING PROMPT (config creation only) ===")
            # Previously this would send a second prompt to test containers. We now skip it.
            test_response = None
            
            # Log the (now single-phase) response from Gemini CLI
            logger.info(f"=== GEMINI CLI RESPONSE FOR DEVOPS ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            logger.info(f"DevOps phase completed - Gemini CLI created deployment files (testing skipped)")
            
            return {
                'status': 'success',
                'response': response,
                'test_response': test_response,
                'message': 'Gemini CLI created deployment configuration files (container testing skipped)'
            }
        except Exception as e:
            logger.error(f"Error in DevOps phase: {str(e)}")
            return {'status': 'error', 'error': str(e)} 

    def _execute_tester_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Tester phase - create tester agent prompt and test-list.md"""
        try:
            # Step 1: Create user-prompt-specific tester agent prompt file
            timestamp = self._get_project_timestamp(project_dir)  # Use project directory name for consistent naming
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            tester_agent_file = f".sureai/.tester_agent_{user_prompt_slug}_{timestamp}.md"
 
            # Create the specific tester agent prompt file first
            create_agent_file_prompt = f"""
 {agent_prompt}
 
 USER PROMPT:
 {agent_output}
 
 INSTRUCTIONS:
 1. Create a specific tester agent prompt file for this user prompt
 2. Create the file: {tester_agent_file}
 3. This file should contain the tester agent prompt customized for this specific project
 4. Write detailed content in the file including:
    - Architecture-driven test planning methodology specific to this project type
    - Test case generation approach based on system architecture and codebase analysis
    - Selenium and pytest usage instructions (Selenium and ChromeDriver are preinstalled)
    - Test structure and organization with multiple subtests per component
    - Customized tester workflow for this project based on architecture components
 5. Include all necessary testing and QA instructions based on the user prompt and architecture
 6. Make the content specific to the user's request, project type, and architectural components
 7. This will be referenced by subsequent agents
 
 IMPORTANT: Write the actual tester agent prompt content in the file, not just create an empty file.
 
 Create the tester agent prompt file with detailed content:
 """
 
            gemini_client = self._get_gemini_client()
            self._log_prompt_to_gemini("tester_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            agent_file_response = self._get_cli_client(task_id, "tester").generate_single_response(create_agent_file_prompt, working_dir=project_dir, agent_name="tester")
            if isinstance(agent_file_response, str) and agent_file_response.strip().lower().startswith("error generating response"):
                logger.error(f"Tester agent prompt creation failed: {agent_file_response}")
                return {'status': 'error', 'error': agent_file_response}
 
            # Step 2: Now create the test-list.md by referring to the created agent file and architecture_document.md
            code_tree_path = self._write_code_tree(project_dir)
            create_test_list_prompt = f"""
 {agent_prompt}
 
 USER PROMPT:
 {agent_output}
 
 REFERENCE FILES:
 @{tester_agent_file}
 @.sureai/architecture_document.md
 @{code_tree_path}
 
 INSTRUCTIONS:
1. Read the tester agent prompt from the reference file above
2. Analyze the user prompt, architecture_document.md, and the entire codebase (backend/ and frontend/)
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/test-list.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create this file in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Ensure your test plan is comprehensive and actionable, with multiple subtests for each architectural component
5. Follow the test-list.md template structure defined in the agent prompt with multiple subtests
6. Explicitly tag any subtests requiring browser automation with `[E2E/Selenium]` in `test-list.md`
7. For subtests tagged `[E2E/Selenium]`, use Selenium WebDriver (Chrome/ChromeDriver) in headless mode; pytest should orchestrate these E2E runs (Selenium and ChromeDriver are preinstalled)
8. Include unit tests, integration tests, system tests, UAT, performance tests, and security tests as appropriate
9. Base your tests on the architecture components and actual code implementation

**CRITICAL: You MUST create this file in the `.sureai/` directory using explicit file paths. Do NOT create it in the root directory.**
 
 Create the test-list.md file based on the reference files:
 """
 
            self._log_prompt_to_gemini("test_list_creation", create_test_list_prompt, agent_prompt, previous_docs)
            response = self._get_cli_client(task_id, "tester").generate_single_response(create_test_list_prompt, working_dir=project_dir, agent_name="tester")
            if isinstance(response, str) and response.strip().lower().startswith("error generating response"):
                logger.error(f"Tester test-list creation failed: {response}")
                return {'status': 'error', 'error': response}
 
            logger.info(f"=== GEMINI CLI RESPONSE FOR TESTER ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
 
            # Step 3: Execute tests sequentially as listed in test-list.md until all tests are completed
            max_iterations = 30
            iteration = 0
            remaining_tests = self._count_open_tests(project_dir)
            while remaining_tests and iteration < max_iterations:
                iteration += 1
                logger.info(f"Tester executing test iteration {iteration}/{max_iterations}. Remaining tests: {remaining_tests}")
                first_idx = self._first_pending_test_index(project_dir)
                run_tests_prompt = f"""
  You have created `.sureai/test-list.md`. Now EXECUTE ALL PENDING TESTS sequentially as listed.
  
  REFERENCE FILES:
  @.sureai/test-list.md
  @{code_tree_path}
  
  REQUIREMENTS:
  - Start from the FIRST pending subtest (index: {first_idx if first_idx is not None else '1'}) and proceed in order. Do NOT skip ahead.
  - Implement missing test code for each pending `- [ ]` subtest.
  - If a subtest fails or indicates that application code is missing/undefined (endpoints, functions, imports, modules, UI elements, etc.), implement the required application code yourself in the correct files, respecting the existing architecture and directory structure. After implementing the code, re-run the current subtest to confirm it passes before moving on.
  - Use pytest to run tests. For any subtest tagged [E2E/Selenium], use Selenium WebDriver in headless mode.
  - After executing each subtest, update `.sureai/test-list.md` by marking it `- [x]` with a brief pass/fail note. For failures, include a short summary and continue to the next subtest.
  - Do not create a new file for test tracking. Update the existing `.sureai/test-list.md` only.
  - Respect the existing project structure when adding test files.
  
  Proceed to implement and run the pending tests now and update `.sureai/test-list.md` accordingly:
  """
                cont = self._get_cli_client(task_id, "tester").generate_single_response(run_tests_prompt, working_dir=project_dir, agent_name="tester")
                if isinstance(cont, str) and cont.strip().lower().startswith("error generating response"):
                    logger.error(f"Tester execution iteration failed: {cont}")
                    # Do not break; allow subsequent iterations to continue progress
                    pass
                remaining_tests = self._count_open_tests(project_dir)
 
            final_remaining = self._count_open_tests(project_dir)
            if final_remaining:
                logger.warning(f"Tester phase finished with {final_remaining} remaining tests")
            else:
                logger.info("All tests in test-list.md executed and marked")
 
            return {
                'status': 'success' if final_remaining == 0 else 'partial',
                'response': response,
                'message': 'Tester executed tests sequentially',
                'remaining_tests': final_remaining
            }
        except Exception as e:
            logger.error(f"Error in tester phase: {str(e)}")
            # Even when there's an error, we should still count remaining tests
            # so the workflow can make informed decisions about continuation
            try:
                remaining_tests = self._count_open_tests(project_dir)
                return {
                    'status': 'error', 
                    'error': str(e),
                    'remaining_tests': remaining_tests
                }
            except Exception as count_error:
                logger.error(f"Error counting tests during error handling: {count_error}")
                return {'status': 'error', 'error': str(e)}

    def _count_open_tests(self, project_dir: str) -> int:
        """Count remaining unchecked tests in .sureai/test-list.md"""
        try:
            tests_path = os.path.join(project_dir, ".sureai", "test-list.md")
            if not os.path.exists(tests_path):
                return 0
            with open(tests_path, 'r', encoding='utf-8') as f:
                content = f.read()
            return len(re.findall(r"^- \[ \] ", content, flags=re.MULTILINE))
        except Exception:
            return 0 

    def _write_code_tree(self, project_dir: str, max_files: int = 1500) -> str:
        """Write a lightweight code tree manifest to .sureai/.code_tree.txt with tree -L 2 -a output.
        Returns the relative path for reference.
        """
        sureai_dir = os.path.join(project_dir, ".sureai")
        os.makedirs(sureai_dir, exist_ok=True)
        manifest_rel = ".sureai/.code_tree.txt"
        manifest_path = os.path.join(project_dir, manifest_rel)
        
        try:
            # Use tree command to generate directory structure
            import subprocess
            tree_cmd = ["tree", "-L", "2", "-a"]
            result = subprocess.run(tree_cmd, cwd=project_dir, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0 and result.stdout.strip():
                # Write the tree output directly
                with open(manifest_path, 'w', encoding='utf-8') as f:
                    f.write("# Project Directory Structure (tree -L 2 -a output)\n\n")
                    f.write(result.stdout)
                logger.info("Generated code tree using 'tree -L 2 -a' command")
            else:
                # Fallback to simple directory listing if tree command fails
                fallback_content = ["# Project Directory Structure (fallback listing)\n"]
                for root, dirs, files in os.walk(project_dir):
                    level = root.replace(project_dir, '').count(os.sep)
                    if level <= 2:  # Limit to 2 levels
                        indent = "  " * level
                        rel_path = os.path.relpath(root, project_dir)
                        if rel_path == ".":
                            fallback_content.append(f"{indent}.")
                        else:
                            fallback_content.append(f"{indent}{os.path.basename(root)}/")
                        
                        if level < 2:  # Only show files at level 2 or below
                            for f in sorted(files):
                                if not f.startswith('.'):  # Skip hidden files
                                    fallback_content.append(f"{indent}  {f}")
                
                with open(manifest_path, 'w', encoding='utf-8') as f:
                    f.write("\n".join(fallback_content))
                logger.info("Generated code tree using fallback directory listing")
                
            # Truncate file if it's too large
            try:
                if os.path.getsize(manifest_path) > max_files * 200:
                    with open(manifest_path, 'r+', encoding='utf-8') as f:
                        content = f.readlines()
                        f.seek(0)
                        f.writelines(content[:max_files])
                        f.truncate()
            except Exception:
                pass
        except Exception as e:
            # If tree command fails entirely, write a minimal placeholder
            try:
                with open(manifest_path, 'w', encoding='utf-8') as f:
                    f.write("# Project Directory Structure (tree -L 2 -a not available)\n")
                    f.write(str(e))
            except Exception:
                pass
        
        return manifest_rel

    def _write_directory_structure(self, project_dir: str) -> str:
        """Write a detailed directory structure to .sureai/.directory_structure.txt.
        Returns the relative path for reference.
        """
        sureai_dir = os.path.join(project_dir, ".sureai")
        os.makedirs(sureai_dir, exist_ok=True)
        manifest_rel = ".sureai/.directory_structure.txt"
        manifest_path = os.path.join(project_dir, manifest_rel)
        
        try:
            # Use tree command to generate detailed directory structure
            import subprocess
            tree_cmd = ["tree", "-a", "-L", "3", "--dirsfirst"]
            result = subprocess.run(tree_cmd, cwd=project_dir, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0 and result.stdout.strip():
                # Write the tree output directly
                with open(manifest_path, 'w', encoding='utf-8') as f:
                    f.write("# Detailed Project Directory Structure (tree -a -L 3 --dirsfirst output)\n\n")
                    f.write(result.stdout)
                logger.info("Generated detailed directory structure using 'tree -a -L 3 --dirsfirst' command")
            else:
                # Fallback to simple directory listing if tree command fails
                fallback_content = ["# Detailed Project Directory Structure (fallback listing)\n\n"]
                for root, dirs, files in os.walk(project_dir):
                    level = root.replace(project_dir, '').count(os.sep)
                    if level <= 3:  # Limit to 3 levels
                        indent = "  " * level
                        rel_path = os.path.relpath(root, project_dir)
                        if rel_path == ".":
                            fallback_content.append(f"{indent}.\n")
                        else:
                            fallback_content.append(f"{indent}{os.path.basename(root)}/\n")
                        
                        # Add files in this directory
                        if level < 3:  # Don't show files at the deepest level
                            for file in files:
                                fallback_content.append(f"{indent}  {file}\n")
                
                with open(manifest_path, 'w', encoding='utf-8') as f:
                    f.writelines(fallback_content)
                logger.info("Generated directory structure using fallback method")
                
        except Exception as e:
            logger.error(f"Error generating directory structure: {e}")
            # Create a minimal fallback
            try:
                with open(manifest_path, 'w', encoding='utf-8') as f:
                    f.write("# Directory Structure (minimal fallback)\n\n")
                    f.write(f"Project root: {os.path.basename(project_dir)}\n")
                    f.write("(Error generating detailed structure)\n")
            except Exception:
                pass
        
        return manifest_rel

    def _first_pending_test_index(self, project_dir: str) -> int | None:
        """Return 1-based index of the first pending test in test-list.md, or None if none."""
        try:
            tests_path = os.path.join(project_dir, ".sureai", "test-list.md")
            if not os.path.exists(tests_path):
                return None
            with open(tests_path, 'r', encoding='utf-8') as f:
                for idx, line in enumerate(f, start=1):
                    if re.match(r"^- \[ \] ", line):
                        return idx
        except Exception:
            return None
        return None 

    def _execute_requirement_builder_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Requirement Builder phase - extract structured context from .sureai/uploads"""
        try:
            uploads_dir = os.path.join(project_dir, '.sureai', 'uploads')
            os.makedirs(uploads_dir, exist_ok=True)
            output_json = os.path.join(project_dir, '.sureai', 'requirements_extracted.json')
            # Build a code tree manifest to assist navigation
            code_tree_path = self._write_code_tree(project_dir)
            # Compose prompt with strict multi-modal extraction instructions
            create_extraction_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE PATHS:
@{code_tree_path}

WORKING FOLDER:
{uploads_dir}

INSTRUCTIONS:
1. Iterate every file under the folder above: {uploads_dir}
2. Identify the file type for each item. Supported types include images (png, jpg, jpeg, gif, webp), PDFs (text-based and scanned/image PDFs), Excel (.xlsx), and CSV (.csv). Process other text-like files (txt, md, docx) if present.
3. If it is an image (png/jpg/jpeg/gif/webp):
   - Perform Optical Character Recognition (OCR) to extract every piece of visible text.
   - Describe visual elements: layout, color scheme, icons/logos/graphics.
   - Analyze relationships between elements and overall structure (e.g., header, footer, body, sidebar).
4. If it is a PDF:
   - For text PDFs, extract full text and preserve structure: headings, paragraphs, lists, tables, and page numbers.
   - For scanned/image PDFs, run OCR for all pages and extract text; include any detected tables.
5. If it is an Excel (.xlsx):
   - For each sheet, extract: sheet name, headers, inferred column types when obvious, and rows. Include a structured representation as sheets: [ {{ name, headers: [...], rows: [[...]] }} ].
6. If it is a CSV:
   - Extract headers and all rows. Provide a structured representation as {{ headers: [...], rows: [[...]] }}.
7. For each processed source file, WRITE a STRICT JSON file (UTF-8, no markdown, no comments, no trailing commas) to this per-file path:
   - Per-file output path: {uploads_dir}/<BASENAME_WITHOUT_EXTENSION>.json
   - The per-file JSON should include appropriate keys. When applicable, include: summary, title, text_blocks, ocr_text, buttons, sections, navigation, form, tables, lists, icons, images, footer_note, layout, styles, metadata (with content_type, page_count?, dimensions?, sheet_names?), and for CSV/Excel a normalized table/sheets structure.
8. After writing all per-file JSON files, CREATE an index JSON at the path: {output_json} containing ONLY entries for files whose per-file JSON actually exists:
   - files: array of objects with {{ filename, type, size_bytes, json_path: path relative to project root, summary? }} for each processed file in {uploads_dir}
   - totals: {{ files_processed, json_files_created }}
9. Do not delete or modify any input files.

HARD CONSTRAINTS:
- You MUST perform all extraction and file writes yourself via terminal commands. The backend will NOT create per-file JSONs for you.
- Do NOT rely on any server-side fallback; if a tool is missing, install it inline and proceed.
- The index must not include entries for files whose per-file JSON was not created.

COMMAND REQUIREMENTS:
- Respond only with terminal commands to perform the steps above directly in the file system.
- If OCR or parsers are missing, install required tools inline first (e.g., "apt-get update && apt-get install -y poppler-utils tesseract-ocr") but prefer pure-Python when available.
- Ensure EVERY per-file JSON is valid and complete; do not truncate.
"""
            # Send to Gemini CLI
            gemini_client = self._get_gemini_client()
            self._log_prompt_to_gemini('requirement_builder', create_extraction_prompt, agent_prompt, previous_docs)
            response = self._get_cli_client(task_id, "requirement_builder").generate_single_response(create_extraction_prompt, working_dir=project_dir, agent_name="requirement_builder")
            if isinstance(response, str) and response.strip().lower().startswith("error generating response"):
                logger.error(f"Requirement builder failed: {response}")
                return {'status': 'error', 'error': response}
            # Optionally, verify output files exist
            try:
                # Expected JSONs are every non-.json file mirrored to <basename>.json
                expected_jsons: List[str] = []
                created_jsons: List[str] = []
                for entry in os.listdir(uploads_dir):
                    entry_path = os.path.join(uploads_dir, entry)
                    if os.path.isfile(entry_path) and not entry.lower().endswith('.json'):
                        base, _ = os.path.splitext(entry)
                        expected_path = os.path.join(uploads_dir, f"{base}.json")
                        expected_jsons.append(expected_path)
                for json_path in expected_jsons:
                    try:
                        if os.path.exists(json_path) and os.path.getsize(json_path) > 0:
                            created_jsons.append(os.path.relpath(json_path, project_dir))
                    except Exception:
                        pass
                index_ok = False
                try:
                    index_ok = os.path.exists(output_json) and os.path.getsize(output_json) > 0
                except Exception:
                    index_ok = False
                ok = len(created_jsons) >= 1 and index_ok
            except Exception:
                ok = False
                created_jsons = []
            return {
                'status': 'success' if ok else 'partial',
                'response': response,
                'files_created': (created_jsons + ([os.path.relpath(output_json, project_dir)] if os.path.exists(output_json) else [])),
                'message': 'Per-file JSONs and index created' if ok else 'Extraction attempted; some outputs may be missing or empty'
            }
        except Exception as e:
            logger.error(f"Error in requirement builder phase: {str(e)}")
            return {'status': 'error', 'error': str(e)} 

    def _execute_documentation_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Documentation phase - create Technical and User Manuals at project root"""
        try:
            # Prepare identifiers
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            doc_agent_file = f".sureai/.documentation_agent_{user_prompt_slug}_{timestamp}.md"

            # Ensure .sureai exists
            os.makedirs(os.path.join(project_dir, '.sureai'), exist_ok=True)

            # Create a lightweight code tree manifest to guide small-snippet references
            code_tree_path = self._write_code_tree(project_dir)

            # Step 1: Create user-specific documentation agent directive file
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific documentation agent directive file for this user prompt
2. Create the file: {doc_agent_file}
3. This file should contain precise instructions for generating both a Technical Manual and a User Manual for this project
4. Include:
   - Document scopes and audiences
   - Required sections for both manuals (as in the base prompt)
   - Code referencing policy: cite only small important code chunks (<=20 lines), annotate file paths, and summarize when longer
   - Tables requirement for API specs and settings
   - Style and formatting guidance (headings, ToC, code fences)
5. Tailor the content to the user's request and available inputs

IMPORTANT: Write detailed content into the file, not an empty placeholder.

Create the documentation agent directive file with detailed content:
"""

            gemini_client = self._get_gemini_client()
            self._log_prompt_to_gemini("documentation_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            agent_file_response = self._get_cli_client(task_id, "documentation_agent").generate_single_response(create_agent_file_prompt, working_dir=project_dir, agent_name="documentation_agent")
            if isinstance(agent_file_response, str) and agent_file_response.strip().lower().startswith("error generating response"):
                logger.error(f"Documentation agent directive creation failed: {agent_file_response}")
                return {'status': 'error', 'error': agent_file_response}

            # Step 2: Create the Technical and User Manuals at project root
            create_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{doc_agent_file}
@.sureai/prd_document.md
@.sureai/architecture_document.md
@{code_tree_path}

INSTRUCTIONS:
1. Read the documentation agent directive from @{doc_agent_file}
2. Analyze the PRD and Architecture documents
3. Use the code tree manifest to reference only small important chunks from `backend/` and `frontend/` when necessary (<=20 lines per snippet), quoting file paths. Summarize longer code rather than pasting.
4. Create the following files at the PROJECT ROOT (not inside .sureai/):
   - `technical_manual.md` — architecture, APIs, data models, dev setup, build/deploy, security, performance, environments
   - `user_manual.md` — features explained for end users with step-by-step guides, workflows, troubleshooting
5. Formatting requirements:
   - Include a Table of Contents at the top of each manual
   - Use headings, lists, tables; code fences for commands and JSON examples
   - For API Reference: table of method, path, purpose, auth, headers, params/body, responses, errors
   - Cite source files and paths inline when referencing code
6. If information is missing, add an "Open Questions" section listing concrete gaps.

IMPORTANT: Create the actual files directly using your file system access. Do not output the file content here; write to disk.

Create the two manuals now at the project root:
"""

            self._log_prompt_to_gemini("documentation_manuals_creation", create_docs_prompt, agent_prompt, previous_docs)
            response = self._get_cli_client(task_id, "documentation_agent").generate_single_response(create_docs_prompt, working_dir=project_dir, agent_name="documentation_agent")
            if isinstance(response, str) and response.strip().lower().startswith("error generating response"):
                logger.error(f"Documentation manuals creation failed: {response}")
                return {'status': 'error', 'error': response}

            # Verify files exist
            created = []
            for rel in ["technical_manual.md", "user_manual.md"]:
                path = os.path.join(project_dir, rel)
                if os.path.exists(path) and os.path.getsize(path) > 0:
                    created.append(rel)

            return {
                'status': 'success' if len(created) == 2 else ('partial' if created else 'failed'),
                'response': response,
                'files_created': created,
                'message': 'Documentation manuals created at project root' if len(created) == 2 else 'Documentation manuals missing or empty'
            }
        except Exception as e:
            logger.error(f"Error in documentation phase: {str(e)}")
            return {'status': 'error', 'error': str(e)} 

    def _execute_web_search_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Web Search phase - perform web research and create a consolidated report."""
        try:
            # Prepare identifiers
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:5]
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            ws_agent_file = f".sureai/.web_search_agent_{user_prompt_slug}_{timestamp}.md"
            output_rel = ".sureai/web-results.md"
            output_path = os.path.join(project_dir, output_rel)

            os.makedirs(os.path.join(project_dir, '.sureai'), exist_ok=True)

            # Step 1: Create directive file for web search agent
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a short directive file for the Web Search Agent tailored to this user prompt.
2. Create the file: {ws_agent_file}
3. Include specific research goals, primary/secondary keywords, and key questions to answer.

IMPORTANT: Write concrete content into the file, not an empty placeholder.

Create the Web Search Agent directive file now:
"""

            gemini_client = self._get_gemini_client()
            self._log_prompt_to_gemini("web_search_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            agent_file_response = self._get_cli_client(task_id, "web_search").generate_single_response(create_agent_file_prompt, working_dir=project_dir, agent_name="web_search")
            if isinstance(agent_file_response, str) and agent_file_response.strip().lower().startswith("error generating response"):
                logger.error(f"Web Search agent directive creation failed: {agent_file_response}")
                return {'status': 'error', 'error': agent_file_response}

            # Step 2: Perform research and write consolidated report
            create_report_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{ws_agent_file}

INSTRUCTIONS:
1. Perform deep web/market research for the user's topic. Use authoritative, recent sources when applicable.
2. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/web-results.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create this file in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
3. Follow this structure strictly:
   - Executive Summary
   - Research Strategy
   - Landscape Overview
   - Competitor and Similar Solutions (with strengths/weaknesses)
   - Opportunity Analysis (business needs, gaps)
   - Unique Value Propositions
   - Brainstormed Concepts
   - Evidence and Citations (quotes with links)
   - Recommendations and Next Steps
4. For every claim, add inline citations in the form: [Source: <Title> — <Domain> — <URL>].
5. Deduplicate links and include a final links list.
6. If web access is limited, state limitations explicitly, cite from available knowledge, and flag items to validate.

**CRITICAL: You MUST create this file in the `.sureai/` directory using explicit file paths. Do NOT create it in the root directory.**

Create the consolidated web research report now:
"""

            self._log_prompt_to_gemini("web_search_report_creation", create_report_prompt, agent_prompt, previous_docs)
            response = self._get_cli_client(task_id, "web_search").generate_single_response(create_report_prompt, working_dir=project_dir, agent_name="web_search")
            if isinstance(response, str) and response.strip().lower().startswith("error generating response"):
                logger.error(f"Web Search report creation failed: {response}")
                return {'status': 'error', 'error': response}

            # Verify file exists and is non-empty
            created = False
            try:
                if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                    created = True
            except Exception:
                created = False

            return {
                'status': 'success' if created else 'partial',
                'response': response,
                'files_created': [output_rel] if created else [],
                'message': 'Web research report created' if created else 'Attempted to create web research report; file missing or empty'
            }
        except Exception as e:
            logger.error(f"Error in Web Search phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _execute_deep_research_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Deep Research phase - multi-step reasoning and synthesis with iterative refinement."""
        try:
            # Prepare identifiers
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:6]
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            dr_agent_file = f".sureai/.deep_research_agent_{user_prompt_slug}_{timestamp}.md"
            output_rel = ".sureai/research-results.md"
            output_path = os.path.join(project_dir, output_rel)

            os.makedirs(os.path.join(project_dir, '.sureai'), exist_ok=True)

            # Step 1: Create directive file for Deep Research agent
            create_agent_file_prompt = f"""
+{agent_prompt}
+
+USER PROMPT:
+{agent_output}
+
+REFERENCE FILES (if present):
+@.sureai/web-results.md
+@.sureai/requirements_extracted.json
+@.sureai/analysis_document.md
+
+INSTRUCTIONS:
+1. Create a concise directive for the Deep Research process tailored to this user prompt.
+2. Create the file: {dr_agent_file}
+3. Outline objectives, key questions, multi-step plan, and refinement strategy.
+
+Create the Deep Research directive file now:
+"""

            gemini_client = self._get_gemini_client()
            self._log_prompt_to_gemini("deep_research_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            agent_file_response = self._get_cli_client(task_id, "deep_research").generate_single_response(create_agent_file_prompt, working_dir=project_dir, agent_name="deep_research")
            if isinstance(agent_file_response, str) and agent_file_response.strip().lower().startswith("error generating response"):
                logger.error(f"Deep Research directive creation failed: {agent_file_response}")
                return {'status': 'error', 'error': agent_file_response}

            # Step 2: Perform deep research and write synthesized report
            code_tree_path = self._write_code_tree(project_dir)
            create_report_prompt = f"""
+{agent_prompt}
+
+USER PROMPT:
+{agent_output}
+
+REFERENCE FILES (include only those that exist):
+@{dr_agent_file}
+@.sureai/web-results.md
+@.sureai/requirements_extracted.json
+@.sureai/analysis_document.md
+@{code_tree_path}
+
+INSTRUCTIONS:
+1. Execute a multi-step, iterative deep research process based on the directive.
+2. Synthesize complex information across sources and long documents; reconcile contradictions.
+3. **CRITICAL FILE PATH REQUIREMENTS:**
+   - **MUST create `.sureai/research-results.md` in the `.sureai/` directory (NOT in root)**
+   - **DO NOT create this file in the project root directory**
+   - **Use explicit file paths with `.sureai/` prefix**
+4. Follow the required structure: Plan & Strategy, Evidence, Synthesis, Iterative Refinement, Final Answer, References.
+5. For each non-obvious claim, add inline citations: [Source: <Title> — <Domain> — <URL>].
+6. If any referenced files above are missing, proceed without them and note limitations briefly in the report.
+7. When relevant, include:
+   - GitHub/code ecosystem discovery: key repositories, issues/PRs, release cadence, maintenance signals.
+   - News and company updates: reputable news articles, company blogs, product changelogs/release notes.
+
+**CRITICAL: You MUST create this file in the `.sureai/` directory using explicit file paths. Do NOT create it in the root directory.**
+
+Create and save the deep research report now:
+"""

            self._log_prompt_to_gemini("deep_research_report_creation", create_report_prompt, agent_prompt, previous_docs)
            response = self._get_cli_client(task_id, "deep_research").generate_single_response(create_report_prompt, working_dir=project_dir, agent_name="deep_research")
            if isinstance(response, str) and response.strip().lower().startswith("error generating response"):
                logger.error(f"Deep Research report creation failed: {response}")
                # Proceed to attempt creation from response fallbacks
 
            # Verify output exists and non-empty
            created = False
            try:
                if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                    created = True
            except Exception:
                created = False
 
            # Fallback: if CLI didn't write the file, write the response content directly to the target path
            if not created and isinstance(response, str) and response.strip() and not response.strip().lower().startswith("error generating response"):
                try:
                    os.makedirs(os.path.join(project_dir, '.sureai'), exist_ok=True)
                    with open(output_path, 'w', encoding='utf-8') as f:
                        f.write(response)
                    if os.path.getsize(output_path) > 0:
                        created = True
                        logger.info("Deep Research fallback: wrote response content directly to .sureai/research-results.md")
                except Exception as write_e:
                    logger.warning(f"Deep Research fallback write failed: {write_e}")
 
            return {
                'status': 'success' if created else 'partial',
                'response': response,
                'files_created': [output_rel] if created else [],
                'message': 'Deep research report created' if created else 'Attempted to create deep research report; file missing or empty'
            }
        except Exception as e:
            logger.error(f"Error in Deep Research phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _execute_coding_standards_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Coding Standards phase - generate coding-standard.md based on tech stack document only"""
        try:
            # Identifiers
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            cs_agent_file = f".sureai/.coding_standards_agent_{user_prompt_slug}_{timestamp}.md"
            output_rel = ".sureai/coding-standard.md"
            output_path = os.path.join(project_dir, output_rel)

            # Ensure .sureai exists
            os.makedirs(os.path.join(project_dir, '.sureai'), exist_ok=True)

            # Step 1: Create user-specific Coding Standards agent directive file (for traceability)
            create_agent_file_prompt = f"""
+{agent_prompt}
+
+USER PROMPT:
+{agent_output}
+
+INSTRUCTIONS:
+1. Create a specific Coding Standards agent directive file for this user prompt
+2. Create the file: {cs_agent_file}
+3. This file should contain high-level guidance on how to extract coding standards from the selected tech stack
+4. Keep it concise; the actual standards will be written to coding-standard.md in the next step
+
+IMPORTANT: Write concrete content; do not leave the file empty.
+
+Create the Coding Standards directive file now:
+"""

            gemini_client = self._get_gemini_client()
            self._log_prompt_to_gemini("coding_standards_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            _ = self._get_cli_client(task_id, "coding_standards").generate_single_response(create_agent_file_prompt, working_dir=project_dir, agent_name="coding_standards")

            # Step 2: Generate .sureai/coding-standard.md referring ONLY to tech_stack_document.md
            create_standards_prompt = f"""
+{agent_prompt}
+
+USER PROMPT:
+{agent_output}
+
+REFERENCE FILES (ONLY):
+@.sureai/tech_stack_document.md
+
+INSTRUCTIONS:
+1. Read the tech stack document and generate a clear, actionable `coding-standard.md` placed at `.sureai/coding-standard.md`.
+2. Include TWO main sections: Frontend Coding Standards and Backend Coding Standards, tailored to the specified technologies.
+3. For each section, cover at minimum: language/style conventions, lint/format tools and configs, file/folder structure, naming, typing, error handling, logging, configuration/env, API contracts, security, performance, accessibility (frontend), i18n (if applicable), docs/comments.
+4. Provide short command snippets for setting up linters/formatters and sample configs (e.g., eslint/prettier/ruff/mypy) matching the stack.
+5. Keep the document practical and concise, with bullet lists and short examples where helpful.
+
+CRITICAL FILE PATH REQUIREMENTS:
+- MUST create `.sureai/coding-standard.md` in the `.sureai/` directory (NOT in root)
+- Use explicit file path `.sureai/coding-standard.md`
+
+Create and save the coding standards document now:
+"""

            self._log_prompt_to_gemini("coding_standards_creation", create_standards_prompt, agent_prompt, previous_docs)
            response = self._get_cli_client(task_id, "coding_standards").generate_single_response(create_standards_prompt, working_dir=project_dir, agent_name="coding_standards")

            # Verify output exists and non-empty; if not, write response directly as fallback
            created = False
            try:
                if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                    created = True
            except Exception:
                created = False

            if not created and isinstance(response, str) and response.strip() and not response.strip().lower().startswith("error generating response"):
                try:
                    with open(output_path, 'w', encoding='utf-8') as f:
                        f.write(response)
                    created = os.path.getsize(output_path) > 0
                except Exception:
                    created = False

            return {
                'status': 'success' if created else 'partial',
                'response': response,
                'files_created': [output_rel] if created else [],
                'message': 'Coding standards document created' if created else 'Attempted to create coding standards document; file missing or empty'
            }
        except Exception as e:
            logger.error(f"Error in Coding Standards phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _execute_ui_ux_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute UI/UX phase - generate ui-ux.md based on the selected frontend tech stack"""
        try:
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            ux_agent_file = f".sureai/.ui_ux_agent_{user_prompt_slug}_{timestamp}.md"
            output_rel = ".sureai/ui-ux.md"
            output_path = os.path.join(project_dir, output_rel)

            os.makedirs(os.path.join(project_dir, '.sureai'), exist_ok=True)

            # Step 1: Create a brief UI/UX directive for traceability
            create_agent_file_prompt = f"""
+{agent_prompt}
+
+USER PROMPT:
+{agent_output}
+
+INSTRUCTIONS:
+1. Create a concise UI/UX directive tailored to this user prompt and the selected frontend stack.
+2. Create the file: {ux_agent_file}
+3. Outline the design philosophy, component strategy, theming approach, accessibility priorities, and responsive layout grid.
+
+Create the UI/UX directive file now:
+"""

            gemini_client = self._get_gemini_client()
            self._log_prompt_to_gemini("ui_ux_agent_file_creation", create_agent_file_prompt, agent_prompt, previous_docs)
            _ = self._get_cli_client(task_id, "ui_ux").generate_single_response(create_agent_file_prompt, working_dir=project_dir, agent_name="ui_ux")

            # Step 2: Generate .sureai/ui-ux.md referring ONLY to tech_stack_document.md
            create_ux_prompt = f"""
+{agent_prompt}
+
+USER PROMPT:
+{agent_output}
+
+REFERENCE FILES (ONLY):
+@.sureai/tech_stack_document.md
+
+INSTRUCTIONS:
+1. Read the tech stack document and generate a clear, actionable `.sureai/ui-ux.md` describing a modern component library and UX guidelines aligned to the chosen FRONTEND stack.
+2. Include at minimum:
+   - Design tokens: color palette (light/dark), typography scale, spacing, radius, elevation, motion.
+   - Theming: light/dark strategy, CSS variables/tokens, theme switching approach for the chosen stack.
+   - Layout: responsive grid/breakpoints, container widths, app shell patterns (header, sidebar, footer), page templates.
+   - Accessibility: WCAG basics, keyboard/focus, ARIA patterns for complex widgets.
+   - Core components with brief API notes and when-to-use: Button, Input, Select, Textarea, Checkbox, Radio, Toggle/Switch, Badge, Avatar, Tooltip, Popover, Modal/Drawer, Toast/Alert, Tabs, Accordion, Breadcrumbs, Pagination, Card, Table/DataGrid, List/VirtualList, Stepper, Skeleton/Loading, Empty states.
+   - Data viz (if relevant to stack): chart primitives and lib choice based on stack (e.g., Recharts/ECharts/Chart.js), theming hooks.
+   - Forms: validation strategy and library (Formik/React Hook Form/VeeValidate/Angular Forms), error patterns, async submit.
+   - Navigation: routing conventions for the stack (Next.js/Vue Router/Angular Router/SvelteKit), active states, breadcrumbs.
+   - State management (UI-level): where to keep UI state (local vs context/store), optimistic UI, loading/skeleton patterns.
+   - Internationalization (if applicable): library choice and message patterns.
+   - Performance: code-splitting, lazy-loading, memoization, virtualization patterns.
+   - Recommended UI library or headless components matching the stack (e.g., React: MUI/Tailwind+Headless UI/Shadcn; Vue: Vuetify/Naive UI; Angular: Angular Material; Svelte: Skeleton/Tailwind).
+3. Provide quick setup snippets/configs aligned to the stack (e.g., install commands, theme provider setup, Tailwind config if applicable).
+4. Keep it practical and concise with headings and bullet points. Tailor names and examples to the detected stack from tech_stack_document.md.
+
+CRITICAL FILE PATH REQUIREMENTS:
+- MUST create `.sureai/ui-ux.md` in the `.sureai/` directory (NOT in root)
+- Use explicit file path `.sureai/ui-ux.md`
+
+Create and save the UI/UX document now:
+"""

            self._log_prompt_to_gemini("ui_ux_creation", create_ux_prompt, agent_prompt, previous_docs)
            response = self._get_cli_client(task_id, "ui_ux").generate_single_response(create_ux_prompt, working_dir=project_dir, agent_name="ui_ux")

            created = False
            try:
                if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                    created = True
            except Exception:
                created = False

            if not created and isinstance(response, str) and response.strip() and not response.strip().lower().startswith("error generating response"):
                try:
                    with open(output_path, 'w', encoding='utf-8') as f:
                        f.write(response)
                    created = os.path.getsize(output_path) > 0
                except Exception:
                    created = False

            return {
                'status': 'success' if created else 'partial',
                'response': response,
                'files_created': [output_rel] if created else [],
                'message': 'UI/UX document created' if created else 'Attempted to create UI/UX document; file missing or empty'
            }
        except Exception as e:
            logger.error(f"Error in UI/UX phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # If we have a dict with a single key, extract its content
                                agent_content = str(list(agent_content.values())[0])
                        elif isinstance(agent_content, list):
                            # If we have a list, convert to string
                            agent_content = json.dumps(agent_content, indent=2)
                        
                        # Write the agent prompt content to the file
                        with open(agent_file_path, 'w') as f:
                            f.write(agent_content)
                    except json.JSONDecodeError:
                        # If the response is not JSON, write it as is
                        with open(agent_file_path, 'w') as f:
                            f.write(agent_file_response)
                except Exception as e:
                    raise Exception(f"Failed to create analyst agent file: {e}")
            else:
                # If not using SureCli, the CLI should create the agent file itself
                pass

            return {
                "agent_file": agent_file_path,
                "agent_file_response": agent_file_response,
            }
        except Exception as e:
            raise Exception(f"Failed to execute analyst phase: {e}")

    def _execute_architect_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Architect phase - create architecture and tech stack documents"""
        try:
            # Use the same implementation as io8architect but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            architect_agent_file = f".sureai/.architect_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific architect agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific architect agent prompt file for this user prompt
2. Create the file: {architect_agent_file}
3. This file should contain the architect agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Architecture methodology specific to this project type
   - Tech stack selection approach for this particular user request
   - System design framework
   - Customized architect workflow for this project
5. Include all necessary architecture and tech stack instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual architect agent prompt content in the file, not just create an empty file.

Create the architect agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            architect_cli = self._get_cli_client(task_id, "architect")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, architect_cli)
            agent_file_response = architect_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="architect")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(architect_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(architect_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, architect_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract known section content if available
                                if 'architecture' in content_data or 'tech_stack' in content_data:
                                    part_a = content_data.get('architecture')
                                    part_b = content_data.get('tech_stack')
                                    if isinstance(part_a, (dict, list)):
                                        part_a = json.dumps(part_a, indent=2)
                                    if isinstance(part_b, (dict, list)):
                                        part_b = json.dumps(part_b, indent=2)
                                    parts = [p for p in [part_a, part_b] if p]
                                    agent_content = "\n\n".join(parts) if parts else agent_content
                                elif 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract known section content if available
                                if 'architecture' in content_data or 'tech_stack' in content_data:
                                    part_a = content_data.get('architecture')
                                    part_b = content_data.get('tech_stack')
                                    if isinstance(part_a, (dict, list)):
                                        part_a = json.dumps(part_a, indent=2)
                                    if isinstance(part_b, (dict, list)):
                                        part_b = json.dumps(part_b, indent=2)
                                    parts = [p for p in [part_a, part_b] if p]
                                    agent_content = "\n\n".join(parts) if parts else agent_content
                                elif 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract known section content if available
                                if 'architecture' in content_data or 'tech_stack' in content_data:
                                    part_a = content_data.get('architecture')
                                    part_b = content_data.get('tech_stack')
                                    if isinstance(part_a, (dict, list)):
                                        part_a = json.dumps(part_a, indent=2)
                                    if isinstance(part_b, (dict, list)):
                                        part_b = json.dumps(part_b, indent=2)
                                    parts = [p for p in [part_a, part_b] if p]
                                    agent_content = "\n\n".join(parts) if parts else agent_content
                                elif 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created analyst analysis and requirements documents'
            }
            
        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _execute_architect_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Architect phase - create architecture and tech stack documents"""
        try:
            # Use the same implementation as io8architect but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            architect_agent_file = f".sureai/.architect_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific architect agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific architect agent prompt file for this user prompt
2. Create the file: {architect_agent_file}
3. This file should contain the architect agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Architecture methodology specific to this project type
   - Tech stack selection approach for this particular user request
   - System architecture framework
   - Tech stack development strategy
   - Customized architect workflow for this project
5. Include all necessary architecture and tech stack instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual architect agent prompt content in the file, not just create an empty file.

Create the architect agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            architect_cli = self._get_cli_client(task_id, "architect")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, architect_cli)
            agent_file_response = architect_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="architect")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(architect_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(architect_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, architect_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(effective_working_dir, io8architect_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    # Extract breakdown and plan content if available
                                    if isinstance(json_data, dict):
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# io8 System Architect Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard io8architect agent with project-specific customizations above.
Refer to the base io8architect agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {io8architect_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {io8architect_agent_file}: {e}")
            
            self._log_created_paths('Python Parser' if getattr(io8architect_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_ar - before_ar)))
            
            # Step 2: Now create the architecture documents by referring to the created agent file and previous documents
            create_architecture_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{io8architect_agent_file}
@.sureai/analysis_document.md
@.sureai/requirements_document.md

INSTRUCTIONS:
1. Read the io8architect agent prompt from the reference file above
2. Analyze the user prompt and previous analysis documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/architecture_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/tech_stack_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the architecture design approach defined in the agent prompt
5. Build upon the analysis and requirements documents
6. Create comprehensive architecture and tech stack based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the architecture and tech stack documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            io8architect_docs_cli = self._get_cli_client(task_id, "io8architect")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_architecture_docs_prompt, project_dir, io8architect_docs_cli)
            response = io8architect_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="io8architect")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(io8architect_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR io8architect ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

            try:
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(response)
                created = os.path.getsize(output_path) > 0
            except Exception:
                created = False

            return {
                'status': 'success' if created else 'partial',
                'response': response,
                'files_created': [output_rel] if created else [],
                'message': 'UI/UX document created' if created else 'Attempted to create UI/UX document; file missing or empty'
            }
        except Exception as e:
            logger.error(f"Error in UI/UX phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created analyst analysis and requirements documents'
            }
            
        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_io8_mcp_project_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute io8 MCP Project phase - create a project builder plan or scaffolding instructions"""
        try:
            timestamp = self._get_project_timestamp(project_dir)
            builder_file = f".sureai/.io8_mcp_project_{timestamp}.md"
            
            # Extract the project name from the directory path
            project_name = os.path.basename(project_dir)
            
            # Create the specific io8 MCP project agent prompt file
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

PROJECT NAME:
{project_name}

INSTRUCTIONS:
1. Create a specific io8 MCP project agent prompt file for this user prompt
2. Create the file: {builder_file}
3. This file should contain the io8 MCP project agent prompt customized for this specific project
4. Write detailed content in the file including:
   - io8 MCP project methodology specific to this project type
   - Project scaffolding approach for this particular user request
   - io8 MCP workflow framework
   - Customized io8 MCP workflow for this project
5. Include all necessary io8 MCP project instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent steps

IMPORTANT: Write the actual io8 MCP project agent prompt content in the file, not just create an empty file.

Create the io8 MCP project agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            io8_mcp_project_cli = self._get_cli_client(task_id, "io8_mcp_project")
            before = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, io8_mcp_project_cli)
            agent_file_response = io8_mcp_project_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="io8_mcp_project")
            after = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(io8_mcp_project_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after - before)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(io8_mcp_project_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, builder_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
```

```
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)

        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}

    def _build_memory_block(self, task_id: str, agent_name: str) -> str:
        """Compose memory summary + latest JSON + active-file hint for inclusion in CLI prompts."""
        try:
            from src.core.task_manager import TaskManager
            tm = TaskManager()
            mem = tm.get_task_memory(task_id)
            summary = []
            history = mem.get('history', [])[-3:]
            if history:
                summary.append("=== MEMORY (Recent runs) ===")
                for item in history:
                    ts = item.get('timestamp') or ''
                    pr = item.get('prompt') or ''
                    wf = item.get('workflow_id') or ''
                    prog = item.get('agents_progress') or {}
                    completed = ", ".join(prog.get('completed', []) or [])
                    remaining = ", ".join(prog.get('remaining', []) or [])
                    summary.append(f"- [{ts}] prompt: {pr}\n  workflow: {wf}\n  completed: {completed or '-'}\n  remaining: {remaining or '-'}")
            latest = mem.get('history', [])[-1] if mem.get('history') else None
            json_block = ""
            active_hint = ""
            if latest and isinstance(latest, dict):
                to_send = {
                    'prompt': latest.get('prompt'),
                    'workflow_id': latest.get('workflow_id'),
                    'agents_progress': latest.get('agents_progress', {}),
                    'agents_details': latest.get('agents_details', {}),
                }
                json_block = "\n\n=== MEMORY JSON (Latest) ===\n" + json.dumps(to_send, indent=2)
                details = (to_send.get('agents_details') or {}).get(agent_name) or {}
                in_progress_file = details.get('in_progress_file')
                if in_progress_file:
                    active_hint = f"\n\n=== ACTIVE FILE FOR {agent_name.upper()} ===\nContinue from this file: @{in_progress_file}\n(If the file is missing, recreate it and resume where you left off.)"
            pieces = []
            if summary:
                pieces.append("\n\n" + "\n".join(summary))
            if json_block:
                pieces.append(json_block)
            if active_hint:
                pieces.append(active_hint)
            return "".join(pieces)
        except Exception:
            return ""
    
    def _detect_base_project_sureai_location(self, project_dir: str) -> str:
        """Detect the location of base project .sureai directory"""
        try:
            # First check root .sureai
            sureai_dir = os.path.join(project_dir, '.sureai')
            if os.path.exists(sureai_dir):
                predefined_docs = [
                    'analysis_document.md', 'requirements_document.md',
                    'architecture_document.md', 'tech_stack_document.md',
                    'prd_document.md', 'project_plan.md'
                ]
                found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sureai_dir, doc)))
                if found_count >= 3:
                    logger.info(f"🎯 Found base project .sureai at root: {sureai_dir}")
                    return sureai_dir
            
            # If not found in root, check subdirectories for base project .sureai
            for root, dirs, files in os.walk(project_dir):
                if '.sureai' in dirs:
                    sub_sureai = os.path.join(root, '.sureai')
                    if sub_sureai != sureai_dir:  # Skip root .sureai we already checked
                        predefined_docs = [
                            'analysis_document.md', 'requirements_document.md',
                            'architecture_document.md', 'tech_stack_document.md',
                            'prd_document.md', 'project_plan.md'
                        ]
                        found_count = sum(1 for doc in predefined_docs if os.path.exists(os.path.join(sub_sureai, doc)))
                        if found_count >= 3:
                            logger.info(f"🎯 Found base project .sureai at: {sub_sureai}")
                            return sub_sureai
                # Don't recurse too deep
                if root.count(os.sep) - project_dir.count(os.sep) >= 3:
                    break
            
            logger.info("🔍 No base project .sureai directory found with sufficient predefined documents")
            return None
            
        except Exception as e:
            logger.warning(f"Error detecting base project .sureai location: {e}")
            return None

    def _execute_analyst_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Analyst phase - create analysis and requirements documents"""
        try:
            # Use the same implementation as io8analyst but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            analyst_agent_file = f".sureai/.analyst_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific analyst agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific analyst agent prompt file for this user prompt
2. Create the file: {analyst_agent_file}
3. This file should contain the analyst agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Analysis methodology specific to this project type
   - Requirements analysis approach for this particular user request
   - Business analysis framework
   - User story development strategy
   - Customized analyst workflow for this project
5. Include all necessary analysis and requirements instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual analyst agent prompt content in the file, not just create an empty file.

Create the analyst agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            analyst_cli = self._get_cli_client(task_id, "analyst")
            before_a = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, analyst_cli)
            agent_file_response = analyst_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="analyst")
            after_a = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                agent_file_path = os.path.join(project_dir, analyst_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('breakdown') or
                            response_data.get('plan') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            # If we have a dict with breakdown/plan keys, extract their content
                            if 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    if isinstance(json_data, dict):
                                        # Extract breakdown and plan content if available
                                        if 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# Business Analyst Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard analyst agent with project-specific customizations above.
Refer to the base analyst agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {analyst_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {analyst_agent_file}: {e}")
            self._log_created_paths('Python Parser' if getattr(analyst_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_a - before_a)))
            
            # Step 2: Now create the analysis documents by referring to the created agent file and previous documents
            create_analysis_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{analyst_agent_file}
@.sureai/.io8codermaster_breakdown.md
@.sureai/.io8codermaster_plan.md

INSTRUCTIONS:
1. Read the analyst agent prompt from the reference file above
2. Analyze the user prompt and previous io8codermaster documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/analysis_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/requirements_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the requirements and structure defined in the agent prompt
5. Build upon the io8codermaster breakdown and plan
6. Create comprehensive analysis and requirements based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the analysis and requirements documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            analyst_docs_cli = self._get_cli_client(task_id, "analyst")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_analysis_docs_prompt, project_dir, analyst_docs_cli)
            response = analyst_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="analyst")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR analyst ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(analyst_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"analyst phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created analyst analysis and requirements documents'
            }
            
        except Exception as e:
            logger.error(f"Error in analyst phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}




    def _execute_architect_phase(self, task_id: str, agent_output: str, project_dir: str, previous_docs: Dict[str, str], agent_prompt: str = "") -> Dict[str, Any]:
        """Execute Architect phase - create architecture and tech stack documents"""
        try:
            # Use the same implementation as io8architect but with standard file names
            timestamp = self._get_project_timestamp(project_dir)
            user_prompt_words = agent_output.split()[:3]  # First 3 words of user prompt
            user_prompt_slug = '_'.join(user_prompt_words).lower().replace('-', '_')
            architect_agent_file = f".sureai/.architect_agent_{user_prompt_slug}_{timestamp}.md"
            
            # Create the specific architect agent prompt file first
            create_agent_file_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

INSTRUCTIONS:
1. Create a specific architect agent prompt file for this user prompt
2. Create the file: {architect_agent_file}
3. This file should contain the architect agent prompt customized for this specific project
4. Write detailed content in the file including:
   - Architecture design methodology specific to this project type
   - Technical architecture approach for this particular user request
   - System design framework
   - Technology selection strategy
   - Customized architect workflow for this project
5. Include all necessary architecture and tech stack instructions based on the user prompt
6. Make the content specific to the user's request and project type
7. This will be referenced by subsequent agents

IMPORTANT: Write the actual architect agent prompt content in the file, not just create an empty file.

Create the architect agent prompt file with detailed content:
"""
            
            # Get response from CLI to create the agent file
            architect_cli = self._get_cli_client(task_id, "architect")
            before_ar = self._snapshot_tree(project_dir)
            # Inject document contents for SureCli
            injected_agent_prompt = self._inject_document_contents(create_agent_file_prompt, project_dir, architect_cli)
            agent_file_response = architect_cli.generate_single_response(injected_agent_prompt, working_dir=project_dir, agent_name="architect")
            after_ar = self._snapshot_tree(project_dir)
            
            # When using SureCli, the Python parser should create the agent file itself
            if getattr(architect_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient':
                # Create the agent file with the response content
                # For non-io8 architect, write to project_dir's .sureai
                architect_agent_file = architect_agent_file if 'architect_agent_file' in locals() else f".sureai/.architect_agent_{user_prompt_slug}_{timestamp}.md"
                agent_file_path = os.path.join(project_dir, architect_agent_file)
                try:
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(agent_file_path), exist_ok=True)
                    
                    # Properly format the agent-specific prompt file content
                    # Extract the actual agent prompt content from the JSON response
                    import json
                    try:
                        # Try to parse the response as JSON first
                        response_data = json.loads(agent_file_response)
                        # Look for agent prompt content in various possible keys
                        agent_content = (
                            response_data.get('agent_prompt') or 
                            response_data.get('content') or 
                            response_data.get('prompt') or 
                            response_data.get('architecture') or
                            response_data.get('tech_stack') or
                            str(response_data)
                        )
                        
                        # Handle nested JSON structures more effectively
                        if isinstance(agent_content, dict):
                            if 'architecture' in agent_content or 'tech_stack' in agent_content:
                                part_a = agent_content.get('architecture')
                                part_b = agent_content.get('tech_stack')
                                import json
                                if isinstance(part_a, (dict, list)):
                                    part_a = json.dumps(part_a, indent=2)
                                if isinstance(part_b, (dict, list)):
                                    part_b = json.dumps(part_b, indent=2)
                                parts = [p for p in [part_a, part_b] if p]
                                agent_content = "\n\n".join(parts) if parts else str(response_data)
                            elif 'breakdown' in agent_content and 'plan' in agent_content:
                                breakdown_content = agent_content['breakdown']
                                plan_content = agent_content['plan']
                                # If these are also dicts or lists, convert to string
                                if isinstance(breakdown_content, (dict, list)):
                                    breakdown_content = json.dumps(breakdown_content, indent=2)
                                if isinstance(plan_content, (dict, list)):
                                    plan_content = json.dumps(plan_content, indent=2)
                                # Combine the content
                                agent_content = f"{breakdown_content}\n\n{plan_content}"
                            else:
                                # Convert dict to properly formatted string
                                agent_content = json.dumps(agent_content, indent=2)
                        elif isinstance(agent_content, list):
                            # Convert list to properly formatted string
                            agent_content = json.dumps(agent_content, indent=2)
                    except json.JSONDecodeError:
                        # If not JSON, use the response as-is but format it properly
                        agent_content = agent_file_response
                    
                    # Handle the case where agent_content is a JSON string wrapped in markdown code blocks
                    if isinstance(agent_content, str) and '```json' in agent_content:
                        # Extract content between ```json and ```
                        try:
                            start_idx = agent_content.find('```json')
                            if start_idx != -1:
                                end_idx = agent_content.find('```', start_idx + 7)  # 7 is length of '```json'
                                if end_idx != -1:
                                    json_content = agent_content[start_idx + 7:end_idx].strip()
                                    # Parse the JSON content
                                    json_data = json.loads(json_content)
                                    # Extract known section content if available
                                    if isinstance(json_data, dict):
                                        if 'architecture' in json_data or 'tech_stack' in json_data:
                                            part_a = json_data.get('architecture')
                                            part_b = json_data.get('tech_stack')
                                            if isinstance(part_a, (dict, list)):
                                                part_a = json.dumps(part_a, indent=2)
                                            if isinstance(part_b, (dict, list)):
                                                part_b = json.dumps(part_b, indent=2)
                                            parts = [p for p in [part_a, part_b] if p]
                                            agent_content = "\n\n".join(parts) if parts else agent_content
                                        elif 'breakdown' in json_data and 'plan' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            plan_content = json_data['plan']
                                            # If these are also dicts or lists, convert to string
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            # Combine the content without JSON formatting
                                            agent_content = f"{breakdown_content}\n\n{plan_content}"
                                        elif 'breakdown' in json_data:
                                            breakdown_content = json_data['breakdown']
                                            if isinstance(breakdown_content, (dict, list)):
                                                breakdown_content = json.dumps(breakdown_content, indent=2)
                                            agent_content = breakdown_content
                                        elif 'plan' in json_data:
                                            plan_content = json_data['plan']
                                            if isinstance(plan_content, (dict, list)):
                                                plan_content = json.dumps(plan_content, indent=2)
                                            agent_content = plan_content
                        except (json.JSONDecodeError, Exception):
                            # If parsing fails, keep the original content
                            pass
                    
                    # Additional processing to extract content from nested JSON structure
                    if isinstance(agent_content, str) and agent_content.strip().startswith('{') and agent_content.strip().endswith('}'):
                        try:
                            # Try to parse as JSON again if it's a string representation of JSON
                            content_data = json.loads(agent_content)
                            if isinstance(content_data, dict):
                                # Extract breakdown and plan content if available
                                if 'breakdown' in content_data and 'plan' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    plan_content = content_data['plan']
                                    # If these are also dicts or lists, convert to string
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    # Combine the content without JSON formatting
                                    agent_content = f"{breakdown_content}\n\n{plan_content}"
                                elif 'breakdown' in content_data:
                                    breakdown_content = content_data['breakdown']
                                    if isinstance(breakdown_content, (dict, list)):
                                        breakdown_content = json.dumps(breakdown_content, indent=2)
                                    agent_content = breakdown_content
                                elif 'plan' in content_data:
                                    plan_content = content_data['plan']
                                    if isinstance(plan_content, (dict, list)):
                                        plan_content = json.dumps(plan_content, indent=2)
                                    agent_content = plan_content
                        except json.JSONDecodeError:
                            # If parsing fails, keep the original content
                            pass
                    
                    # Format the content as proper markdown for an agent prompt file
                    formatted_content = f"""# io8 System Architect Agent - Customized for This Project

## Project-Specific Instructions

{agent_content}

## Base Agent Prompt Reference

This agent is based on the standard io8architect agent with project-specific customizations above.
Refer to the base io8architect agent prompt for general principles and workflow instructions.
"""
                    
                    # Write the properly formatted agent file content
                    with open(agent_file_path, 'w', encoding='utf-8') as f:
                        f.write(formatted_content)
                    logger.info(f"✅ Python Parser created agent file: {io8architect_agent_file}")
                except Exception as e:
                    logger.error(f"❌ Failed to create agent file {io8architect_agent_file}: {e}")
            
            self._log_created_paths('Python Parser' if getattr(architect_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_ar - before_ar)))
            
            # Step 2: Now create the architecture documents by referring to the created agent file and previous documents
            create_architecture_docs_prompt = f"""
{agent_prompt}

USER PROMPT:
{agent_output}

REFERENCE FILES:
@{architect_agent_file}
@.sureai/analysis_document.md
@.sureai/requirements_document.md

INSTRUCTIONS:
1. Read the architect agent prompt from the reference file above
2. Analyze the user prompt and previous analysis documents
3. **CRITICAL FILE PATH REQUIREMENTS:**
   - **MUST create `.sureai/architecture_document.md` in the `.sureai/` directory (NOT in root)**
   - **MUST create `.sureai/tech_stack_document.md` in the `.sureai/` directory (NOT in root)**
   - **DO NOT create these files in the project root directory**
   - **Use explicit file paths with `.sureai/` prefix**
4. Follow the architecture design approach defined in the agent prompt
5. Build upon the analysis and requirements documents
6. Create comprehensive architecture and tech stack based on the user prompt

**CRITICAL: You MUST create these files in the `.sureai/` directory using explicit file paths. Do NOT create them in the root directory.**

Create the architecture and tech stack documents based on the reference files:
"""
            
            before_docs = self._snapshot_tree(project_dir)
            architect_docs_cli = self._get_cli_client(task_id, "architect")
            # Inject document contents for SureCli
            injected_docs_prompt = self._inject_document_contents(create_architecture_docs_prompt, project_dir, architect_docs_cli)
            response = architect_docs_cli.generate_single_response(injected_docs_prompt, working_dir=project_dir, agent_name="architect")
            after_docs = self._snapshot_tree(project_dir)
            self._log_created_paths('Python Parser' if getattr(architect_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI', sorted(list(after_docs - before_docs)))
            
            # Log the response from CLI
            logger.info(f"=== CLI RESPONSE FOR architect ===")
            logger.info(f"RESPONSE LENGTH: {len(response)} characters")
            logger.info("RESPONSE:")
            logger.info("=" * 80)
            logger.info(response)
            logger.info("=" * 80)
            
            source = 'Python Parser' if getattr(architect_docs_cli, '__class__', type('X', (), {})).__name__ == 'SureCliClient' else 'Gemini CLI'
            logger.info(f"architect phase completed - Created by: {source}")
            
            return {
                'status': 'success',
                'response': response,
                'message': 'CLI created architect architecture and tech stack documents'
            }
            
        except Exception as e:
            logger.error(f"Error in architect phase: {str(e)}")
            return {'status': 'error', 'error': str(e)}